-- Polygon generation script
local PolygonGenerator = require(game.ServerScriptService.TruePolygonModuleScript)

-- Image generation script
local ImageGenerator = require(game.ServerScriptService.ImageGenerationModule)

-- Get the ReplicatedStorage service
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local eventToServer = ReplicatedStorage.remoteEventToServer
local eventToClient = ReplicatedStorage.remoteEventToClient

-- Get the HttpService
local HttpService = game:GetService("HttpService")

-- Get the MessagingService
local CLIENT_ID = "tSWRxV5jRIrw0FeFo2yQJzz8qH1UKUMg"
local CLIENT_SECRET = "7I8u9TjIFAG3kmVQY3gTNubIXcaDSlB8F449GkhVHudOcVI1OeXeV6glAte5QiTz"
local THING_ID = "65354776-75f9-41af-a050-0b19c01115f6"

-- Message to server
local messageToServerID = "3e8579e0-4495-43f5-8352-61f367ac4ff4"
local messageToServer = ""

-- Message to arduino
local messageToArduinoID = "b84ced63-a353-4e3e-a9fa-d83a95092f6e"
local messageToArduino = ""

-- Arduino communication
local lastMessageFromArduinoNumber = 0
local lastArduinoCommunication = 0
local lastArduinoCloudRead = 0
local lastDataOut = 0
local lastDataIn = 0

-- Recently executed command
local mostRecentConfirmedExecutedCommand = "0000000"

-- Start time of script
local codeStartTime = tick() * 1000

-- Define varible for Gcode
local processedGCode = {}

-- Motor constants Units & limits
local STEPS_PER_INCH = 127
local INCHES_PER_STUD = 1
local STEPS_PER_STUD = STEPS_PER_INCH * INCHES_PER_STUD
local MAX_TRAVEL_INCH = 36
local MAX_TRAVEL_STEPS = math.floor(MAX_TRAVEL_INCH * STEPS_PER_INCH)
local MAX_TRAVEL_STUDS = MAX_TRAVEL_INCH / INCHES_PER_STUD

-- Minumium time delay
local MIN_DELAY_TENTHS = 20

-- Last delay value
local lastBaseDelayMs = 2.0

-- Money symbol marks multi-chunk payloads
local BUNDLE_MARK = "$"

-- Seperator for splitting chunks inside one bundled message
local CHUNK_SEP = "|" 

-- Max chunks per bundle (14 is max for 1000 byte limit)
local TARGET_BUNDLE_COUNT = 14

-- Max bytes per chunk (bytes total, minus 1 byte for chunk ID)
local MAX_IOT_BYTES = 1000

--––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

-- Visual colors for fiber IDs
local colorMap = {
	-- White
	[0] = Color3.fromRGB(255, 255, 255),
	-- Black
	[1] = Color3.fromRGB(0, 0, 0),
	-- Red
	[2] = Color3.fromRGB(255, 0, 0),
	-- Green
	[3] = Color3.fromRGB(0, 16, 176),
	-- Blue
	[4] = Color3.fromRGB(255, 255, 0),
	-- Orange
	[5] = Color3.fromRGB(0, 255, 0),
	-- Pink
	[6] = Color3.fromRGB(44, 101, 29),
	-- Purple
	[7] = Color3.fromRGB(255, 0, 191),
	-- Yellow
	[8] = Color3.fromRGB(91, 93, 105),
	-- Gray
	[9] = Color3.fromRGB(159, 161, 172),
	-- Cyan
	[10] = Color3.fromRGB(218, 133, 65),
	-- Cyan
	[11] = Color3.fromRGB(180, 128, 255),
	-- Cyan
	[12] = Color3.fromRGB(170, 85, 0),
	-- Cyan
	[13] = Color3.fromRGB(4, 175, 236),
	-- Cyan
	[14] = Color3.fromRGB(106, 57, 9),
	-- Cyan
	[15] = Color3.fromRGB(107, 50, 124),
	-- Cyan
	[16] = Color3.fromRGB(151, 0, 0),
	-- Cyan
	[17] = Color3.fromRGB(212, 144, 189),
}

--–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

-- Handshake state: keep sending I T<id62> every 5s until we see a ping back
local waitingForResponce = false
local lastTInstantAtMs = 0
local lastPayloadId62 = ""

-- Global seed to control the "random" look but keep it deterministic
local COLOR_NOISE_SEED = 31415926

-- Simple deterministic hash-based noise in [0,1], based on position + seed
local function hashNoise01(x, z, salt)
	salt = salt or 0

	-- Quantize so tiny float noise doesn't matter
	local xi = math.floor(x * 100 + 0.5)
	local zi = math.floor(z * 100 + 0.5)

	-- Combine into one number
	local n = xi * 15731 + zi * 789221 + salt * 1376312589

	-- Classic sin hash → frac(sin(n) * big)
	local s = math.sin(n) * 43758.5453
	return s - math.floor(s)
end

-- Current milisecond
local function nowMs()
	return tick() * 1000
end

-- Start cycle for ping T command
local function startTPingCycle(id62)
	lastPayloadId62 = id62 or "00000"
	waitingForResponce = true
	lastTInstantAtMs = 0
end

-- Converts studs to steps for the Arduino motor
local function studsToSteps(studs)
	return math.floor(studs * STEPS_PER_STUD)
end

-- helpers
local function clamp(n, lo, hi) 
	return math.max(lo, math.min(hi, n))
end


local function clampWorldStuds(xStuds, zStuds)
	return math.clamp(xStuds, 0, MAX_TRAVEL_STUDS), math.clamp(zStuds, 0, MAX_TRAVEL_STUDS)
end


local function twoDigitMs(ms) -- 0.0..9.9 -> "XY" where X=whole, Y=tenth
	ms = clamp(ms or 0, 0, 9.9)
	local whole = math.floor(ms)
	local tenth = math.floor((ms - whole) * 10 + 0.5)
	return string.format("%d%d", whole, tenth) -- exactly 2 chars
end


local function packSteps5(steps) -- 4-digit magnitude + sign flag ('0' for +/0, '1' for -)
	local sign = (steps < 0) and "1" or "0"
	local mag = math.min(math.abs(math.floor(steps + 0.5)), 9999)
	return string.format("%04d%s", mag, sign) -- exactly 5 chars
end

-- Converts a list of {x,z} points into a flat list: {x1,z1,x2,z2,...}
local function flatten(poly2d)
	local out = {}
	for _, pt in ipairs(poly2d) do
		out[#out+1] = pt[1]
		out[#out+1] = pt[2]
	end
	return out
end

-- Converts a flat {x1,z1,x2,z2,...} list into a list of {x,z} pairs
local function unflatten(tab)
	local out = {}
	for i=1,#tab,2 do
		out[#out+1] = { tab[i], tab[i+1] }
	end
	return out
end

-- Returns true if the point is inside the polygon (ray-casting algorithm)
local function pointInPolygon(pt, poly)
	local x,z,inside = pt[1], pt[2], false
	for i=1,#poly do
		local a,b = poly[i], poly[(i%#poly)+1]
		if ((a[2]>z) ~= (b[2]>z))
			and (x < (b[1]-a[1])*(z-a[2])/(b[2]-a[2]) + a[1])
		then inside = not inside end
	end
	return inside
end

-- Treat points on edges as inside (helps with kissing/just-touching cases)
local function pointInPolygonInclusive(pt, poly)
	local px, pz = pt[1], pt[2]

	-- Edge check
	for i = 1, #poly do
		local a = poly[i]
		local b = poly[(i % #poly) + 1]
		local ax, az, bx, bz = a[1], a[2], b[1], b[2]
		local cross = (bx - ax) * (pz - az) - (bz - az) * (px - ax)
		if math.abs(cross) <= 1e-6 then
			if px >= math.min(ax, bx) - 1e-6 and px <= math.max(ax, bx) + 1e-6
				and pz >= math.min(az, bz) - 1e-6 and pz <= math.max(az, bz) + 1e-6 then
				return true
			end
		end
	end

	-- Ray cast
	local inside = false
	for i = 1, #poly do
		local a = poly[i]
		local b = poly[(i % #poly) + 1]
		local az, bz = a[2], b[2]
		if (az > pz) ~= (bz > pz) then
			local xhit = a[1] + (pz - az) * (b[1] - a[1]) / (bz - az)
			if px <= xhit then inside = not inside end
		end
	end
	return inside
end


local function coveredByAny(pt, fragments)
	for _, f in ipairs(fragments) do
		if pointInPolygonInclusive(pt, f.outer) then
			return true
		end
	end
	return false
end


local function msToTenths(ms)
	ms = clamp(tonumber(ms) or 2.5, 0.2, 9.9)
	return math.floor(ms * 10 + 0.5)
end


local function bboxDiagonal(loop)
	local minX, maxX = loop[1][1], loop[1][1]
	local minZ, maxZ = loop[1][2], loop[1][2]
	for i = 2, #loop do
		local x, z = loop[i][1], loop[i][2]
		if x < minX then minX = x end
		if x > maxX then maxX = x end
		if z < minZ then minZ = z end
		if z > maxZ then maxZ = z end
	end
	local dx, dz = (maxX - minX), (maxZ - minZ)
	return math.sqrt(dx*dx + dz*dz)
end

-- Gets an attribute or returns a fallback default; warns if missing
local function getWithDefault(inst, attrName, default)
	local v = inst:GetAttribute(attrName)
	if v == nil then
		warn(("! %q missing attribute %q; defaulting to %s"):format(
			inst.Name, attrName, tostring(default)
			))
		return default
	end
	return v
end

-- Converts a number (0–61) to one base62 character
local function numToBase62(n)
	n = math.abs(n)
	local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	n = math.clamp(math.floor(n or 0), 0, 61)
	return string.sub(chars, n + 1, n + 1)
end

-- Converts a single base62 character to a number (0–61)
local function base62ToNum(ch)
	if not ch or #ch == 0 then return 0 end
	
	local byte = string.byte(ch)
	if byte >= 48 and byte <= 57 then return byte - 48 end -- 0–9
	if byte >= 65 and byte <= 90 then return 10 + (byte - 65) end -- A–Z
	if byte >= 97 and byte <= 122 then return 36 + (byte - 97) end -- a–z
	return 0
end

-- Pack 5 booleans into 1 base62 char (bit0–bit4)
function packBooleansToBase62(b1, b2, b3, b4, b5)
	local bits = 0
	if b1 then bits = bit32.bor(bits, bit32.lshift(1, 0)) end
	if b2 then bits = bit32.bor(bits, bit32.lshift(1, 1)) end
	if b3 then bits = bit32.bor(bits, bit32.lshift(1, 2)) end
	if b4 then bits = bit32.bor(bits, bit32.lshift(1, 3)) end
	if b5 then bits = bit32.bor(bits, bit32.lshift(1, 4)) end
	return numToBase62(bits)
end

-- Unpack 1 base62 char into 5 booleans
function unpackBooleansFromBase62(ch)
	local n = base62ToNum(ch)
	local b1 = bit32.band(n, bit32.lshift(1, 0)) ~= 0
	local b2 = bit32.band(n, bit32.lshift(1, 1)) ~= 0
	local b3 = bit32.band(n, bit32.lshift(1, 2)) ~= 0
	local b4 = bit32.band(n, bit32.lshift(1, 3)) ~= 0
	local b5 = bit32.band(n, bit32.lshift(1, 4)) ~= 0
	return b1, b2, b3, b4, b5
end

-- Clear a folder, or create it if it doesn't exist
local function clearFolder(name)
	local f = workspace:FindFirstChild(name)
	if f then
		for _,c in ipairs(f:GetChildren()) do c:Destroy() end
	else
		f = Instance.new("Folder", workspace)
		f.Name = name
	end
	return f
end

-- Gather & sort objects by Index descending
local function gatherInitialObjects(FolderLocation)
	local folder = workspace:FindFirstChild(FolderLocation)
	if not folder then
		warn("Folder '"..tostring(FolderLocation).."' not found — skipping")
		return {}
	end
	local list = {}
	for _, inst in ipairs(folder:GetChildren()) do
		if not inst:IsA("BasePart") then continue end
		local shape = "rectangle"
		if inst.Shape == Enum.PartType.Cylinder then
			shape = "circle"
		elseif inst:IsA("WedgePart") or inst.Shape==Enum.PartType.Wedge then
			shape = "triangle"
		end
		local sz = inst.Size
		list[#list+1] = {
			instance = inst,
			shape = shape,
			rawX = sz.X,
			rawY = sz.Y,
			rawZ = sz.Z,
			colorId = getWithDefault(inst, "Color", 0),
			colorId2 = getWithDefault(inst, "Color2", 1),
			colorId3 = getWithDefault(inst, "Color3", 0),
			colorId4 = getWithDefault(inst, "Color4", 0),
			colorsUsed = getWithDefault(inst, "colorsUsed", 1),
			chunkLength = getWithDefault(inst, "chunkLength", 1),
			colorBlendFace = getWithDefault(inst, "ColorBlendFacing", "X"),
			colorBlendPrecent = getWithDefault(inst, "ColorBlendPrecent", 100),
			ColorBlendEdgeLines = getWithDefault(inst, "ColorBlendEdgeLines", true),
			index = getWithDefault(inst, "Index", 0),
			edgeRows = getWithDefault(inst, "edgeRows", 0),
			density = getWithDefault(inst, "Density", 0),
			motorSpeed = getWithDefault(inst, "MotorSpeed", 2.5),
			ColorFillType = getWithDefault(inst, "ColorFillType", "Fill"),
		}
	end
	table.sort(list, function(a,b) return a.index > b.index end)
	return list
end

-- ==== Numeric robustness / snapping ====
local COORD_GRID = 1e-4 -- 0.0001 studs; tiny vs your machine scale
local SAT_EPS = 1e-5 -- epsilon for SAT & bbox tests
local BOOLEAN_EPS = 1e-3 -- how much to dilate before boolean union

local function snapCoord(x)
	-- snap to global grid to avoid 1.0000000002 vs 0.9999999998
	return math.floor(x / COORD_GRID + 0.5) * COORD_GRID
end

local function regularizeLoop(loop)
	if not loop or #loop < 3 then return loop end

	local out = {}
	local function same(p, q)
		return math.abs(p[1] - q[1]) < COORD_GRID
			and math.abs(p[2] - q[2]) < COORD_GRID
	end

	for i = 1, #loop do
		local p = loop[i]
		local px, pz = snapCoord(p[1]), snapCoord(p[2])
		local snapped = { px, pz }

		local prev = out[#out]
		if not prev or not same(prev, snapped) then
			out[#out+1] = snapped
		end
	end

	-- drop duplicate last point if it wraps to the first
	if #out >= 2 and same(out[1], out[#out]) then
		table.remove(out, #out)
	end

	-- if we somehow collapsed it, just return original
	if #out < 3 then
		return loop
	end

	return out
end

-- SAT overlap & AABB‐touch helper
local function getAxes(poly)
	local axes = {}
	for i=1,#poly do
		local p1,p2 = poly[i], poly[(i%#poly)+1]
		local dx,dz = p2[1]-p1[1], p2[2]-p1[2]
		local nx,nz = -dz, dx
		local len = math.sqrt(nx*nx + nz*nz)
		axes[#axes+1] = { nx/len, nz/len }
	end
	return axes
end

-- Projects polygon points onto an axis and returns the min/max range (used in SAT overlap test)
local function project(poly,axis)
	local mn,mx
	for _,pt in ipairs(poly) do
		local d = pt[1]*axis[1] + pt[2]*axis[2]
		mn = mn and math.min(mn,d) or d
		mx = mx and math.max(mx,d) or d
	end
	return mn,mx
end

-- Return bounding box of a polygon
local function getBBox(poly)
	local minX,maxX = poly[1][1], poly[1][1]
	local minZ,maxZ = poly[1][2], poly[1][2]

	for _,p in ipairs(poly) do
		local x = p[1] :: number
		local z = p[2] :: number

		minX,maxX = math.min(minX,x), math.max(maxX,x)
		minZ,maxZ = math.min(minZ,z), math.max(maxZ,z)
	end
	return minX,maxX,minZ,maxZ
end


-- Remove almost-colinear vertices (prevents degenerate boolean outputs after snapping)
local function pruneColinear(loop, eps)
	eps = eps or 1e-12
	if not loop or #loop < 3 then return loop end
	local out = {}
	local n = #loop
	local function cross(ax, az, bx, bz)
		return ax*bz - az*bx
	end
	for i = 1, n do
		local prev = loop[(i-2) % n + 1]
		local curr = loop[i]
		local nxt  = loop[i % n + 1]
		local ax, az = curr[1] - prev[1], curr[2] - prev[2]
		local bx, bz = nxt[1] - curr[1],  nxt[2] - curr[2]
		if math.abs(cross(ax, az, bx, bz)) > eps then
			out[#out+1] = curr
		end
	end
	return (#out >= 3) and out or loop
end

-- Inflate axis-aligned rectangles by a tiny amount (in grid units) to make "touch-only" cases overlap for booleans.
local function isAxisAlignedRect(loop)
	if type(loop) ~= "table" or #loop ~= 4 then return false end
	local minX,maxX,minZ,maxZ = getBBox(loop)
	for i=1,4 do
		local p = loop[i]
		local x,z = p[1], p[2]
		if not ((x==minX or x==maxX) and (z==minZ or z==maxZ)) then
			return false
		end
	end
	return true
end

local function rectFromBBox(minX,maxX,minZ,maxZ)
	return {
		{minX,minZ},
		{maxX,minZ},
		{maxX,maxZ},
		{minX,maxZ},
	}
end

local function inflateRectIfPossible(loop, units)
	if not loop then return loop end
	if (units or 0) == 0 then return loop end
	if not isAxisAlignedRect(loop) then return loop end
	local minX,maxX,minZ,maxZ = getBBox(loop)
	local d = (units or 1) * COORD_GRID
	return rectFromBBox(minX - d, maxX + d, minZ - d, maxZ + d)
end

local function cleanupLoop(loop)
	if not loop then return loop end
	loop = regularizeLoop(loop)
	loop = pruneColinear(loop, 1e-12)
	return loop
end


-- Do separating axis theorem test on two polygons in XZ plane
local function polygonsOverlap(a, b)
	if #a == 0 or #b == 0 then
		return false
	end

	-- Early AABB check to kill corner-only contact:
	-- if both width and height of intersection are ~0, it's just a point.
	local minXA, maxXA = a[1][1], a[1][1]
	local minZA, maxZA = a[1][2], a[1][2]
	for i = 2, #a do
		local x, z = a[i][1], a[i][2]
		if x < minXA then minXA = x end
		if x > maxXA then maxXA = x end
		if z < minZA then minZA = z end
		if z > maxZA then maxZA = z end
	end

	local minXB, maxXB = b[1][1], b[1][1]
	local minZB, maxZB = b[1][2], b[1][2]
	for i = 2, #b do
		local x, z = b[i][1], b[i][2]
		if x < minXB then minXB = x end
		if x > maxXB then maxXB = x end
		if z < minZB then minZB = z end
		if z > maxZB then maxZB = z end
	end

	local overlapW = math.min(maxXA, maxXB) - math.max(minXA, minXB)
	local overlapH = math.min(maxZA, maxZB) - math.max(minZA, minZB)

	-- Corner-only: both dims ~0 → treat as NO overlap.
	-- Edge sharing: one dim ~0 but the other > 0 → keep as overlap.
	if overlapW <= SAT_EPS and overlapH <= SAT_EPS then
		return false
	end

	-- SAT proper (same as before, with small epsilon)
	for _, ax in ipairs(getAxes(a)) do
		local mnA, mxA = project(a, ax)
		local mnB, mxB = project(b, ax)
		if mxA < mnB - SAT_EPS or mxB < mnA - SAT_EPS then
			return false
		end
	end

	for _, ax in ipairs(getAxes(b)) do
		local mnA, mxA = project(a, ax)
		local mnB, mxB = project(b, ax)
		if mxA < mnB - SAT_EPS or mxB < mnA - SAT_EPS then
			return false
		end
	end

	return true
end

-- Do bounding boxes touch or overlap
local function boxesTouch(aPoly,bPoly,dA,dB)
	dA,dB = dA or 0, dB or 0
	local minXA,maxXA,minZA,maxZA = getBBox(aPoly)
	local minXB,maxXB,minZB,maxZB = getBBox(bPoly)
	minXA,maxXA = minXA-dA, maxXA+dA
	minZA,maxZA = minZA-dA, maxZA+dA
	minXB,maxXB = minXB-dB, maxXB+dB
	minZB,maxZB = minZB-dB, maxZB+dB
	return not (
		maxXA < minXB - SAT_EPS or
			maxXB < minXA - SAT_EPS or
			maxZA < minZB - SAT_EPS or
			maxZB < minZA - SAT_EPS
	)

end

-- Compute the centroid of a 2D loop
local function computeCentroid(loop)
	local sx, sz = 0, 0
	for _, pt in ipairs(loop) do
		sx = sx + pt[1]
		sz = sz + pt[2]
	end
	return { sx / #loop, sz / #loop }
end

-- Polygon area
local function polygonArea(poly)
	local a = 0
	for i=1,#poly do
		local x1,y1 = poly[i][1], poly[i][2]
		local x2,y2 = poly[(i%#poly)+1][1], poly[(i%#poly)+1][2]
		a = a + (x1*y2 - x2*y1)
	end
	return math.abs(a)*0.5
end

-- toBase62(n, width)
-- n: non-negative integer
-- width (optional): fixed number of chars; if nil/0 -> minimal digits
local function decimalToBase62(n, width)
	n = math.floor(tonumber(n) or 0)
	if n < 0 then n = 0 end
	local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

	-- Fast path for zero
	if n == 0 then
		if width and width > 0 then
			return string.rep("0", width)
		else
			return "0"
		end
	end

	-- Build digits least-significant first
	local out = {}
	while n > 0 do
		local r = n % 62
		out[#out+1] = chars:sub(r + 1, r + 1)
		n = math.floor(n / 62)
	end
	local s = table.concat(out):reverse()

	-- Apply fixed width if requested
	if width and width > 0 then
		if #s < width then
			s = string.rep("0", width - #s) .. s
		elseif #s > width then
			-- Keep least-significant 'width' digits
			s = s:sub(#s - width + 1)
		end
	end
	return s
end

-- Convert base-62 string to decimal
local function base62ToDecimal(input : string)
	local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	local charMap = {}
	for i = 1, #chars do
		charMap[chars:sub(i, i)] = i - 1
	end

	-- NOTE: base-62 is case-sensitive; do NOT alter case
	local result = 0
	for i = 1, #input do
		local c = input:sub(i, i)
		local value = charMap[c]
		if value == nil then
			warn("Invalid character in base-62 string: " .. c.." "..input)
			value = 0
		end
		result = result * 62 + value
	end
	return result
end


-- Return the area of 2D points
local function totalCoveredArea(polygons)
	local total = 0
	for _, poly in ipairs(polygons) do
		-- area of the outer boundary
		local outerA = polygonArea(poly.outer)
		-- subtract out any hole areas
		local holeA = 0
		for _, hole in ipairs(poly.holes or {}) do
			holeA = holeA + polygonArea(hole)
		end
		total = total + (outerA - holeA)
	end
	return total
end

-- Compute signed area (positive if CCW)
local function signedArea(loop)
	local a = 0
	for i = 1, #loop do
		local x1,y1 = loop[i][1], loop[i][2]
		local x2,y2 = loop[(i%#loop)+1][1], loop[(i%#loop)+1][2]
		a = a + (x1*y2 - x2*y1)
	end
	return a * 0.5
end

-- Ensure a loop is wound counter-clockwise
local function ensureCCW(loop)
	if signedArea(loop) < 0 then
		local rev = {}
		for i = #loop, 1, -1 do
			rev[#rev+1] = loop[i]
		end
		return rev
	end
	return loop
end

-- Normalize a 2D vector, returns two numbers
local function norm(vx, vz)
	local L = math.sqrt(vx*vx + vz*vz)
	if L > 0 then
		return vx / L, vz / L
	else
		return 0, 0
	end
end

local function encodeSignPair(xSteps, zSteps)
	-- code = 1 if X-, 2 if Z-, 3 if both -
	local code = (xSteps < 0 and 1 or 0) + (zSteps < 0 and 2 or 0)
	return string.char(string.byte("0") + code)
end


local function absClampTo238k(n)
	n = math.floor(math.abs(n) + 0.5)
	if n > 238327 then n = 238327 end
	return n
end


local function upOrDownDelayTenths(isDown, ms)

	-- When tool is up → always 2.0 ms (i.e., 20 tenths)
	if not isDown then return 20 end
	return msToTenths(ms)
end


local function twoDigit(ms)
	ms = math.floor(tonumber(ms) or 0)
	if ms < 0 then ms = 0 end
	if ms > 99 then ms = 99 end
	if ms < 10 then
		return "0" .. tostring(ms)
	end
	return tostring(ms)
end

--––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

-- ABSOLUTE parallel move encoder:
-- O + [delay(2)] + ['0'] + [X_abs(base62,3)] + [Z_abs(base62,3)]
local function makeOAbs(baseDelayMs, xAbsSteps, zAbsSteps)
	if xAbsSteps == nil or zAbsSteps == nil then return nil end

	-- Clamp to your baseline (2.0–9.9 ms)
	baseDelayMs = clamp(baseDelayMs or 2.0, 2.0, 9.9)

	local xAbs = math.clamp(xAbsSteps, 0, MAX_TRAVEL_STEPS)
	local zAbs = math.clamp(zAbsSteps, 0, MAX_TRAVEL_STEPS)

	local payload =
		"O" ..
		twoDigitMs(baseDelayMs) ..
		"0" ..
		decimalToBase62(absClampTo238k(xAbs), 3) ..
		decimalToBase62(absClampTo238k(zAbs), 3)

	-- 1 ('O') + 9 (info) = 10 chars total
	if #payload ~= 10 then return nil end
	return payload
end

local function copyLoop(loop)
	if not loop then return nil end
	local out = table.create(#loop)
	for i = 1, #loop do
		local p = loop[i]
		out[i] = { p[1], p[2] }
	end
	return out
end

local function copyLoops(loops)
	if not loops then return nil end
	local out = table.create(#loops)
	for i = 1, #loops do
		out[i] = copyLoop(loops[i])
	end
	return out
end

-- Build 2D outline from object
local function getPolygon(obj)
	local inst,pos3,yaw = obj.instance, obj.instance.CFrame.p, math.rad(obj.instance.Orientation.Y)
	if obj.shape=="triangle" then yaw = yaw + math.pi end
	local cf2 = CFrame.new(pos3)*CFrame.Angles(0,yaw,0)
	local poly = {}

	if obj.shape=="rectangle" then
		local hx, hz = obj.rawX/2, obj.rawZ/2
		for _,v in ipairs({
			Vector3.new(-hx,0,-hz),
			Vector3.new( hx,0,-hz),
			Vector3.new( hx,0, hz),
			Vector3.new(-hx,0, hz),
			}) do
			local wp = cf2 * v
			poly[#poly+1] = { wp.X, wp.Z }
		end

	elseif obj.shape=="triangle" then
		local b2,h2 = obj.rawY/2, obj.rawZ/2
		for _,v in ipairs({
			Vector3.new(-b2,0,-h2),
			Vector3.new( b2,0,-h2),
			Vector3.new(-b2,0, h2),
			}) do
			local wp = cf2 * v
			poly[#poly+1] = { wp.X, wp.Z }
		end

	else -- circle
		local r,segs = obj.rawY/2, 20
		for i=0,segs-1 do
			local th = 2*math.pi/segs*i
			local wp = cf2 * Vector3.new(math.cos(th)*r,0,math.sin(th)*r)
			poly[#poly+1] = { wp.X, wp.Z }
		end
	end

	return ensureCCW(regularizeLoop(poly))
end

-- Carve away higher‐index overlaps; fully‐contained shapes become special “holes”
local function carveFragments(objs)
	local processed = {}

	for _, obj in ipairs(objs) do
		local base = getPolygon(obj)
		local pieces = {{
			outer = base,
			holes = {},
			colorId = obj.colorId,
			colorId2 = obj.colorId2, 
			colorId3 = obj.colorId3,
			colorId4 = obj.colorId4,
			colorsUsed = obj.colorsUsed,
			chunkLength = obj.chunkLength,
			colorBlendFace = obj.colorBlendFace,
			colorBlendPrecent = obj.colorBlendPrecent,
			colorFillType = obj.ColorFillType,
			ColorBlendEdgeLines = obj.ColorBlendEdgeLines,
			density = obj.density,
			index = obj.index,
			instance = obj.instance,
			edgeRows = obj.edgeRows,
			motorSpeed = obj.motorSpeed,
		}}

		for _, prior in ipairs(processed) do
			local nextPieces = {}

			for _, frag in ipairs(pieces) do
				if frag.colorId==prior.colorId
					or frag.index >= prior.index
					or not polygonsOverlap(frag.outer, prior.outer)
				then
					-- no interaction
					table.insert(nextPieces, frag)

				else
					-- does prior fit entirely inside frag.outer?
					local allInside = true
					for _, vtx in ipairs(prior.outer) do
						if not pointInPolygonInclusive(vtx, frag.outer) then
							allInside = false
							break
						end
					end


					if allInside then
						-- record it as a special hole, keep outer intact
						table.insert(frag.holes, prior.outer)
						table.insert(nextPieces, frag)

					else
						-- normal boolean carve (snap-stable; inflate rectangles if they only touch)
						local aOuter = frag.outer
						local bOuter = prior.outer
						if boxesTouch(aOuter, bOuter) and not polygonsOverlap(aOuter, bOuter) then
							-- touch-only (edge/corner): inflate by 1 grid unit so the boolean has positive-area overlap
							aOuter = inflateRectIfPossible(aOuter, 1)
							bOuter = inflateRectIfPossible(bOuter, 1)
						end
						local diffs = PolygonGenerator(
							flatten(aOuter),
							flatten(bOuter),
							"not"
						)
						if diffs and type(diffs[1])~="table" then diffs={diffs} end
						for _, flat in ipairs(diffs or {}) do
							table.insert(nextPieces, {
								outer = cleanupLoop(unflatten(flat)),
								holes = {}, -- reset holes on split pieces
								colorId = frag.colorId,
								colorId2 = frag.colorId2,
								colorId3 = frag.colorId3,
								colorId4 = frag.colorId4,
								colorsUsed = frag.colorsUsed,
								chunkLength = frag.chunkLength,
								colorBlendFace = frag.colorBlendFace,
								colorBlendPrecent = frag.colorBlendPrecent,
								colorFillType = frag.colorFillType,
								ColorBlendEdgeLines = frag.ColorBlendEdgeLines,
								density = frag.density,
								index = frag.index,
								instance = frag.instance,
								edgeRows = frag.edgeRows,
								motorSpeed = frag.motorSpeed, 
							})
						end
					end
				end
			end

			pieces = nextPieces
			if #pieces==0 then break end
		end

		for _, f in ipairs(pieces) do
			table.insert(processed, f)
		end
	end

	return processed
end

-- Merge Clusters
local function unionLoops(loops)
	local used, out = {}, {}
	for i=1,#loops do used[i]=false end

	for i=1,#loops do
		if not used[i] then
			-- BFS‐cluster any that touch or overlap
			local queue, group = {i},{}
			used[i] = true
			while #queue>0 do
				local idx = table.remove(queue,1)
				group[#group+1] = loops[idx]
				for j=1,#loops do
					if not used[j]
						and boxesTouch(loops[idx], loops[j])
						and polygonsOverlap(loops[idx], loops[j])
					then
						used[j] = true
						queue[#queue+1] = j
					end
				end
			end
			-- now boolean‐union this cluster
			local flats = { flatten(inflateRectIfPossible(group[1], 1)) }
			for k=2,#group do
				local nextF = {}
				for _,fA in ipairs(flats) do
					local res = PolygonGenerator(fA,
						flatten(group[k]),
						"or")
					if res and type(res[1])~="table" then res={res} end
					for _,u in ipairs(res or {}) do
						nextF[#nextF+1] = u
					end
				end
				flats = nextF
			end
			for _,flat in ipairs(flats) do
				out[#out+1] = cleanupLoop(unflatten(flat))
			end
		end
	end

	return out
end

-- Call this AFTER you computed `unionLoopsOut` (array of { {x,z}, ... })
-- and BEFORE attaching holes or emitting final polygons.
local function debugReportRingVoidsRobust(unionLoopsOut, clusterFragments, label)
	-- Estimate a scale to set thresholds (use cluster’s overall bbox)
	local scaleDX, scaleDZ = 0, 0
	do
		local minX, maxX, minZ, maxZ = math.huge, -math.huge, math.huge, -math.huge
		for _, f in ipairs(clusterFragments) do
			for _, p in ipairs(f.outer) do
				local x, z = p[1], p[2]
				if x < minX then minX = x end
				if x > maxX then maxX = x end
				if z < minZ then minZ = z end
				if z > maxZ then maxZ = z end
			end
		end
		scaleDX = math.max(1e-6, maxX - minX)
		scaleDZ = math.max(1e-6, maxZ - minZ)
	end
	local scale = math.max(scaleDX, scaleDZ)

	-- Thresholds relative to cluster size (tune if needed)
	local EPS_AREA = (scale * scale) * 1e-6 -- discard ultra tiny loops
	local EPS_DIAGONAL = scale * 1e-3 -- discard sliver loops
	local PROBE_EPS = scale * 1e-5 -- centroid jitter for coverage test

	local function isTiny(loop)
		if #loop < 3 then return true end
		if polygonArea(loop) < EPS_AREA then return true end
		if bboxDiagonal(loop) < EPS_DIAGONAL then return true end
		return false
	end

	-- Robust "covered" test: centroid + 4 jittered probes
	local function robustCovered(loop)
		local c = computeCentroid(loop)
		if coveredByAny(c, clusterFragments) then return true end
		-- jitter around centroid to survive vertex-on-vertex / kissing cases
		local offsets = {
			{ PROBE_EPS, 0 },
			{-PROBE_EPS, 0 },
			{ 0, PROBE_EPS },
			{ 0, -PROBE_EPS },
		}
		for _, off in ipairs(offsets) do
			local p = { c[1] + off[1], c[2] + off[2] }
			if coveredByAny(p, clusterFragments) then return true end
		end
		return false
	end

	local count = 0
	local printedHeader = false

	for _, loop in ipairs(unionLoopsOut or {}) do
		if loop and #loop >= 3 and (not isTiny(loop)) then
			if not robustCovered(loop) then
				if not printedHeader then
					print(string.format("[VOID-ROBUST]%s non-traditional voids:", label and (" ["..label.."]") or ""))
					printedHeader = true
				end
				count += 1
				local area = polygonArea(loop)
				local c = computeCentroid(loop)
				print(string.format(" • void #%d | area=%.6f | centroid=(%.6f, %.6f) | verts=%d",
					count, area, c[1], c[2], #loop))
			end
		end
	end

	if printedHeader then
		print(string.format("[VOID-ROBUST] total in cluster%s: %d",
			label and (" ["..label.."]") or "", count))
	end
	return count
end

-- Find voids in a poygon, and return a list of their borders
local function detectVoidsOnFinal(finalList)
	local voids = {}

	-- Build a list sorted by instance.Index (descending like initial did)
	local entries = {}
	for _, e in ipairs(finalList) do
		entries[#entries+1] = e
	end
	table.sort(entries, function(a, b)
		local ia = getWithDefault(a.instance, "Index", 0)
		local ib = getWithDefault(b.instance, "Index", 0)
		return ia > ib
	end)

	for i, obj in ipairs(entries) do
		local outer = obj.outer
		local inside = {}

		-- gather all higher-index shapes completely inside `outer`
		for j = 1, i-1 do
			local hi = entries[j]

			-- IMPORTANT:
			-- shapes of the SAME color should not create voids inside each other.
			if hi.colorId ~= obj.colorId then
				local hiPoly = hi.outer

				local allIn = true
				for _, pt in ipairs(hiPoly) do
					if not pointInPolygon(pt, outer) then
						allIn = false
						break
					end
				end

				if allIn then
					-- clip that shape to `outer`
					local diffs = PolygonGenerator(
						flatten(outer),
						flatten(hiPoly),
						"and"
					)
					if diffs and type(diffs[1]) ~= "table" then
						diffs = { diffs }
					end
					for _, flat in ipairs(diffs or {}) do
						inside[#inside+1] = cleanupLoop(unflatten(flat))
					end
				end
			end
		end


		-- cluster & union those “inside” flats into void loops
		local merged = unionLoops(inside)
		for _, loop in ipairs(merged) do
			voids[#voids+1] = loop
		end
	end

	return voids
end

-- Offset a loop of points by a given distance
local function offsetLoop(loop, dist)
	loop = ensureCCW(loop)
	local n = #loop
	if n < 3 then return nil end

	local inset = {}
	for i = 1, n do
		local prev = loop[(i-2) % n + 1]
		local curr = loop[i]
		local next = loop[ i % n + 1 ]

		-- compute inward normals on the two edges meeting at 'curr'
		local e1x, e1z = curr[1]-prev[1], curr[2]-prev[2]
		local n1x, n1z = -e1z, e1x
		n1x, n1z = norm(n1x, n1z)

		local e2x, e2z = next[1]-curr[1], next[2]-curr[2]
		local n2x, n2z = -e2z, e2x
		n2x, n2z = norm(n2x, n2z)

		-- average those two inward normals, renormalize
		local ax, az = (n1x + n2x)/2, (n1z + n2z)/2
		ax, az = norm(ax, az)

		-- move the vertex inward by 'dist'
		inset[#inset+1] = {
			curr[1] + ax * dist,
			curr[2] + az * dist,
		}
	end

	-- if it collapsed to zero area, give up
	if polygonArea(inset) <= 1e-6 then
		return nil
	end

	return inset
end

-- Cluster & union remaining outers, then UNION each shape’s holes
local function clusterAndUnion(frags)
	local byColor, final = {}, {}

	-- bucket by colorId
	for _, f in ipairs(frags) do
		byColor[f.colorId] = byColor[f.colorId] or {}
		table.insert(byColor[f.colorId], f)
	end

	for color, group in pairs(byColor) do
		-- 1) cluster by overlap + density-touch
		local visited, clusters = {}, {}
		for i = 1, #group do visited[i] = false end

		for i, f in ipairs(group) do
			if not visited[i] then
				local queue, cl = { i }, {}
				visited[i] = true

				while #queue > 0 do
					local idx = table.remove(queue, 1)
					table.insert(cl, group[idx])

					for j, g in ipairs(group) do
						if not visited[j]
							and polygonsOverlap(group[idx].outer, g.outer)
							and boxesTouch(
								group[idx].outer, g.outer,
								group[idx].density or 0,
								g.density or 0
							)
						then
							visited[j] = true
							table.insert(queue, j)
						end
					end
				end

				table.insert(clusters, cl)
			end
		end

		-- 2) for each cluster: warn on mismatched density/edgeRows, then union outers + holes
		for _, cl in ipairs(clusters) do
			-- pick a representative
			local proto = cl[1]
			local baseD = proto.density or 0
			local baseER = proto.edgeRows or 0
			local baseMS = tonumber(proto.motorSpeed) or 2.5

			-- warn if any frag differs
			for _, frag in ipairs(cl) do
				if frag.density ~= baseD or frag.edgeRows ~= baseER then
					warn(( "⚠️ Cluster of color %d contains mismatched density/edgeRows:\n" ..
						" %q → density=%s, edgeRows=%s\n" ..
						" %q → density=%s, edgeRows=%s"
						):format(
							color :: string,
							proto.instance and proto.instance.Name or "<nil>",
							baseD, baseER,
							frag.instance and frag.instance.Name or "<nil>",
							frag.density or 0, frag.edgeRows or 0
						))
					break
				end
			end

			-- 2a) union all the cluster’s outer loops (no dilation)
			local flats = { flatten(proto.outer) }
			for k = 2, #cl do
				local nextF = {}
				local bFlat = flatten(inflateRectIfPossible(cl[k].outer, 1))

				for _, fA in ipairs(flats) do
					local res = PolygonGenerator(fA, bFlat, "or")
					if res and type(res[1]) ~= "table" then
						res = { res }
					end
					for _, u in ipairs(res or {}) do
						nextF[#nextF+1] = u
					end
				end

				flats = nextF
			end

			-- 2b) regularize the unioned outers
			local unionLoopsOut = {}
			for _, flat in ipairs(flats) do
				local loop = cleanupLoop(unflatten(flat))
				if loop and #loop >= 3 and polygonArea(loop) > 1e-6 then
					unionLoopsOut[#unionLoopsOut+1] = loop
				end
			end

			-- optional robust void debug
			debugReportRingVoidsRobust(unionLoopsOut, cl, ("color=%d cluster"):format(color :: string))

			-- 2c) gather & union holes across cluster
			local allHoles = {}
			for _, frag in ipairs(cl) do
				for _, hole in ipairs(frag.holes or {}) do
					table.insert(allHoles, hole)
				end
			end
			local mergedHoles = unionLoops(allHoles)

			-- 2d) emit one final polygon per unioned outer
			for _, loop in ipairs(unionLoopsOut) do
				table.insert(final, {
					instance = proto.instance,
					colorId = proto.colorId,
					colorId2 = proto.colorId2,
					colorId3 = proto.colorId3,
					colorId4 = proto.colorId4,
					colorsUsed = proto.colorsUsed,
					chunkLength = proto.chunkLength,
					colorBlendFace = proto.colorBlendFace,
					colorBlendPrecent = proto.colorBlendPrecent,
					colorFillType = proto.colorFillType,
					ColorBlendEdgeLines = proto.ColorBlendEdgeLines,
					outer = loop,
					holes = mergedHoles,
					density = baseD,
					edgeRows = baseER,
					motorSpeed = baseMS,
				})

			end
		end
	end

	return final
end


-- Visualize the border of all polygons in a list
local function visualizePolygons(finalList, yHeight)
	yHeight = yHeight or 1
	local folder = workspace:FindFirstChild("PolygonVisuals")
	if folder then
		for _,c in ipairs(folder:GetChildren()) do c:Destroy() end
	else
		folder = Instance.new("Folder", workspace)
		folder.Name = "PolygonVisuals"
	end

	for _, entry in ipairs(finalList) do
		-- 1) draw outer border in its color
		local col = colorMap[entry.colorId] or Color3.new(1,1,1)
		for i=1,#entry.outer do
			local a,b = entry.outer[i], entry.outer[(i%#entry.outer)+1]
			local A = Vector3.new(a[1], yHeight, a[2])
			local B = Vector3.new(b[1], yHeight, b[2])
			local p = Instance.new("Part", folder)
			p.Size, p.Anchored, p.CanCollide, p.Transparency =
				Vector3.new(0.2,0.2,0.2), true, false, 1
			local att0 = Instance.new("Attachment", p); att0.WorldPosition = A
			local att1 = Instance.new("Attachment", p); att1.WorldPosition = B
			local beam = Instance.new("Beam", p)
			beam.Attachment0, beam.Attachment1 = att0, att1
			beam.FaceCamera = true
			beam.Color = ColorSequence.new(col)
			beam.Width0, beam.Width1 = 0.1, 0.1
		end

		-- 2) draw only black holes, inset slightly
		for _, hole in ipairs(entry.holes or {}) do
			for i=1,#hole do
				local a,b = hole[i], hole[(i%#hole)+1]
				local A = Vector3.new(a[1], yHeight - 0.1, a[2])
				local B = Vector3.new(b[1], yHeight - 0.1, b[2])
				local p = Instance.new("Part", folder)
				p.Size, p.Anchored, p.CanCollide, p.Transparency =
					Vector3.new(0.2,0.2,0.2), true, false, 1
				local att0 = Instance.new("Attachment", p); att0.WorldPosition = A
				local att1 = Instance.new("Attachment", p); att1.WorldPosition = B
				local beam = Instance.new("Beam", p)
				beam.Attachment0, beam.Attachment1 = att0, att1
				beam.FaceCamera = true
				beam.Color = ColorSequence.new(Color3.new(0,0,0))
				beam.Width0, beam.Width1 = 0.1, 0.1
			end
		end
	end
end

-- Visualize the edge loops of a set of polygons
function visualizeEdgeLoops(polygons, yHeight)
	-- clear out prior visuals
	local folder = clearFolder("EdgeVisuals")
	yHeight = yHeight or 1

	for _, entry in ipairs(polygons) do
		local col = colorMap[entry.colorId] or Color3.new(1,1,1)

		-- each entry.edgeLoops[r] is assumed to be a single flat loop (list of {x,z})
		for r, loop in ipairs(entry.edgeLoops or {}) do
			local alpha = 1 - ((r-1) / #entry.edgeLoops)

			for i = 1, #loop do

				if math.random(1,5) == 5 then
					task.wait(0.03)
				end

				local a = loop[i]
				local b = loop[(i % #loop) + 1]

				local A = Vector3.new(a[1], yHeight, a[2])
				local B = Vector3.new(b[1], yHeight, b[2])

				local p = Instance.new("Part", folder)
				p.Size, p.Anchored, p.CanCollide, p.Transparency =
					Vector3.new(0.2,0.2,0.2), true, false, 1 - alpha

				local att0 = Instance.new("Attachment", p)
				att0.WorldPosition = A
				local att1 = Instance.new("Attachment", p)
				att1.WorldPosition = B

				local beam = Instance.new("Beam", p)
				beam.Attachment0, beam.Attachment1 = att0, att1
				beam.FaceCamera = true
				beam.Color = ColorSequence.new(col)
				beam.Width0, beam.Width1 = 0.1, 0.1
			end
		end
	end
end

-- Visualize lines used to fill polygons
local function visualizeFillLines(polygons, yHeight)
	yHeight = yHeight or 1
	local folder = clearFolder("FillVisuals")

	for _, poly in ipairs(polygons) do
		for _, seg in ipairs(poly.fillLines or {}) do
			if math.random(1,10) == 1 then task.wait(0.03) end
			-- pick the segment color first, fall back to polygon color
			local segColorId = seg.colorId or poly.colorId
			local col = colorMap[segColorId] or Color3.new(1,1,1)

			local A = Vector3.new(seg.start.x, yHeight, seg.start.z)
			local B = Vector3.new(seg["end"].x, yHeight, seg["end"].z)

			local p = Instance.new("Part", folder)
			p.Size, p.Anchored, p.CanCollide, p.Transparency =
				Vector3.new(0.2,0.2,0.2), true, false, 0.5

			local att0 = Instance.new("Attachment", p); att0.WorldPosition = A
			local att1 = Instance.new("Attachment", p); att1.WorldPosition = B

			local beam = Instance.new("Beam", p)
			beam.Attachment0, beam.Attachment1 = att0, att1
			beam.FaceCamera = true
			beam.Color = ColorSequence.new(col)
			beam.Width0, beam.Width1 = 0.05, 0.05
		end
	end
end

-- Remove Invalid points
local function pruneLoop(loop, origOuter, holes)
	local out = {}
	for _, pt in ipairs(loop) do
		-- must still be inside the main outline
		if pointInPolygon(pt, origOuter) then
			-- and must NOT lie inside any hole
			local bad = false
			for _, h in ipairs(holes or {}) do
				if pointInPolygon(pt, h) then
					bad = true
					break
				end
			end
			if not bad then
				out[#out+1] = pt
			end
		end
	end
	return #out >= 3 and out or nil
end

-- Build horizontal fill lines across the innermost inset ring
local function splitFillLineAtZ(x1, x2, z, holes)
	local intervals = { { x1, x2 } }

	for _, hole in ipairs(holes) do
		local xs = {}
		for i = 1, #hole do
			local A, B = hole[i], hole[(i % #hole) + 1]
			local zA, zB = A[2], B[2]
			if (zA < z and zB >= z) or (zB < z and zA >= z) then
				local t = (z - zA) / (zB - zA)
				xs[#xs+1] = A[1] + t * (B[1] - A[1])
			end
		end
		table.sort(xs)

		for i = 1, #xs, 2 do
			local h1, h2 = xs[i], xs[i+1]
			if not h2 then break end
			for j = #intervals, 1, -1 do
				local a,b = intervals[j][1], intervals[j][2]
				if not (h2 <= a or h1 >= b) then
					local pieces = {}
					if h1 > a then pieces[#pieces+1] = { a, h1 } end
					if h2 < b then pieces[#pieces+1] = { h2, b } end
					table.remove(intervals, j)
					for k = #pieces, 1, -1 do
						table.insert(intervals, j, pieces[k])
					end
				end
			end
		end
	end

	return intervals
end

-- Build vertical fill lines across the innermost inset ring
local function splitFillLineAtX(z1, z2, x, holes)
	local intervals = { { z1, z2 } }

	for _, hole in ipairs(holes) do
		local zs = {}
		for i = 1, #hole do
			local A, B = hole[i], hole[(i % #hole) + 1]
			local xA, xB = A[1], B[1]
			if (xA < x and xB >= x) or (xB < x and xA >= x) then
				local t = (x - xA) / (xB - xA)
				zs[#zs+1] = A[2] + t * (B[2] - A[2])
			end
		end
		table.sort(zs)

		for i = 1, #zs, 2 do
			local h1, h2 = zs[i], zs[i+1]
			if not h2 then break end
			for j = #intervals, 1, -1 do
				local a, b = intervals[j][1], intervals[j][2]
				if not (h2 <= a or h1 >= b) then
					local pieces = {}
					if h1 > a then pieces[#pieces+1] = { a, h1 } end
					if h2 < b then pieces[#pieces+1] = { h2, b } end
					table.remove(intervals, j)
					for k = #pieces, 1, -1 do
						table.insert(intervals, j, pieces[k])
					end
				end
			end
		end
	end

	return intervals
end

local function chunkIdOf(chunkStr) -- first 5 chars are base-62 ID
	return string.sub(chunkStr, 1, 5)
end

local function indexOfChunkById(chunks, base62Id)
	for i, s in ipairs(chunks) do
		if chunkIdOf(s) == base62Id then return i end
	end
	return nil
end

-- Build a bundle "S$<chunk|chunk|...>" packing up to maxCount, never exceeding maxBytes total.
local function buildChunkBundle(chunks, startBase62Id, maxCount, maxBytes)
	maxCount = math.max(1, math.floor(maxCount or TARGET_BUNDLE_COUNT))
	maxBytes = math.max(64, math.floor(maxBytes or MAX_IOT_BYTES))
	
	if #processedGCode == 0 then
		warn("Arduino requested payload but processedGCode is empty")
		return
	end

	local startIdx = indexOfChunkById(chunks, startBase62Id)
	if not startIdx then return nil, "start id not found" end

	local picked = {}
	local assembled = "S" .. BUNDLE_MARK
	local sepLen = #CHUNK_SEP

	for i = startIdx, math.min(#chunks, startIdx + maxCount - 1) do
		local add = chunks[i]
		local trial = (#picked == 0) and (assembled .. add)
			or (assembled .. CHUNK_SEP .. add)
		if #trial <= maxBytes then
			assembled = trial
			picked[#picked+1] = add
		else
			break
		end
	end

	if #picked == 0 then
		-- Couldn’t fit even one; fallback to single-chunk "S" format
		local one = chunks[startIdx]
		if one then
			local single = "S" .. one
			if #single <= maxBytes then return single, "single-fallback" end
		end
		return nil, "no fit"
	end

	return assembled, "bundle"
end

--Fill polygon with line segments
local function buildFillLinesForPolygon(poly)

	poly.fillLines = {}

	local edgeLoops = poly.edgeLoops or {}
	if #edgeLoops == 0 then
		return
	end

	local inner = edgeLoops[#edgeLoops]
	if not inner or #inner == 0 then
		return
	end

	local first = inner[1]
	local minX, maxX = first[1], first[1]
	local minZ, maxZ = first[2], first[2]

	for _, pt in ipairs(inner) do
		local x = pt[1] :: number
		local z = pt[2] :: number

		minX = math.min(minX, x)
		maxX = math.max(maxX, x)
		minZ = math.min(minZ, z)
		maxZ = math.max(maxZ, z)
	end


	local d = poly.density or 0
	if d <= 0 then return end

	local function buildHorizontal()
		local lines = {}

		local zTop = maxZ - d
		local zBottom = minZ + d
		if zTop < zBottom then return lines end

		local clampLoX = minX + d
		local clampHiX = maxX - d
		if clampLoX >= clampHiX then return lines end

		for z = zTop, zBottom, -d do
			local xs = {}
			for i = 1, #inner do
				local A, B = inner[i], inner[(i % #inner) + 1]
				local zA, zB = A[2], B[2]
				if (zA < z and zB >= z) or (zB < z and zA >= z) then
					local t = (z - zA) / (zB - zA)
					xs[#xs+1] = A[1] + t * (B[1] - A[1])
				end
			end
			table.sort(xs)

			for i = 1, #xs - 1, 2 do
				local x1, x2 = xs[i], xs[i+1]
				x1 = math.clamp(x1, clampLoX, clampHiX)
				x2 = math.clamp(x2, clampLoX, clampHiX)

				if x2 > x1 then
					local safe = splitFillLineAtZ(x1, x2, z, poly.holes or {})
					for _, iv in ipairs(safe) do
						lines[#lines+1] = {
							start = { x = iv[1], z = z },
							["end"] = { x = iv[2], z = z },
						}
					end
				end
			end
		end

		return lines
	end

	local function buildVertical()
		local lines = {}

		local xRight = maxX - d
		local xLeft = minX + d
		if xRight < xLeft then return lines end

		local clampLoZ = minZ + d
		local clampHiZ = maxZ - d
		if clampLoZ >= clampHiZ then return lines end

		for x = xRight, xLeft, -d do
			local zs = {}
			for i = 1, #inner do
				local A, B = inner[i], inner[(i % #inner) + 1]
				local xA, xB = A[1], B[1]
				if (xA < x and xB >= x) or (xB < x and xA >= x) then
					local t = (x - xA) / (xB - xA)
					zs[#zs+1] = A[2] + t * (B[2] - A[2])
				end
			end
			table.sort(zs)

			for i = 1, #zs - 1, 2 do
				local z1, z2 = zs[i], zs[i+1]
				z1 = math.clamp(z1, clampLoZ, clampHiZ)
				z2 = math.clamp(z2, clampLoZ, clampHiZ)

				if z2 > z1 then
					local safe = splitFillLineAtX(z1, z2, x, poly.holes or {})
					for _, iv in ipairs(safe) do
						lines[#lines+1] = {
							start = { x = x, z = iv[1] },
							["end"] = { x = x, z = iv[2] },
						}
					end
				end
			end
		end

		return lines
	end

	-- build both and choose the one with fewer lines
	local horizontalLines = buildHorizontal()
	local verticalLines = buildVertical()

	local nH = #horizontalLines
	local nV = #verticalLines

	if nV > 0 and (nV < nH or nH == 0) then
		poly.fillLines = verticalLines
		poly.fillOrientation = "vertical"
	else
		poly.fillLines = horizontalLines
		poly.fillOrientation = "horizontal"
	end
end


local function mappingPolygonFill(finalList)
	for _, poly in ipairs(finalList) do
		buildFillLinesForPolygon(poly)
	end
end


local function buildEdgeLoopsForPolygon(poly)
	poly.edgeLoops = poly.edgeLoops or {}

	local orig = poly.outer
	local holes = poly.holes or {}
	local rows = poly.edgeRows or 1
	local d = poly.density or 0
	local name = poly.instance and poly.instance.Name or "<nil>"

	if not orig or #orig < 3 then
		poly.edgeLoops = {}
		return
	end

	-- row #1 is just the true border
	poly.edgeLoops[1] = orig
	local prev = orig

	-- now inset rows 2..rows+1
	for r = 2, rows + 1 do
		local shrunk = offsetLoop(prev, d)
		if not shrunk then
			warn(("[%s] edgeRows: offsetLoop collapsed at row %d]"):format(name, r))
			break
		end

		local pruned = pruneLoop(shrunk, orig, holes)
		if not pruned then
			break
		end

		poly.edgeLoops[r] = pruned
		prev = pruned
	end
end


-- Computes & stores edgeLoops on each polygon
local function mappingPolygonRoutes(finalList)
	for _, poly in ipairs(finalList) do
		buildEdgeLoopsForPolygon(poly)
	end
end

-- Color fill functions
local colorFillMap = {
	Fill = function(poly, ctx)
		buildEdgeLoopsForPolygon(poly, ctx) -- border
		buildFillLinesForPolygon(poly, ctx) -- interior
	end,

	MajorPoint = function(poly, ctx)
		-- 1) Build normal borders + fill lines first
		buildEdgeLoopsForPolygon(poly)
		buildFillLinesForPolygon(poly)

		-- Base colors from context / polygon
		local color1 = ctx.colorId or poly.colorId
		local color2 = ctx.colorId2 or poly.colorId2
		local color3 = ctx.colorId3 or poly.colorId3
		local color4 = ctx.colorId4 or poly.colorId4

		-- Require at least 2 colors logically
		local colorsUsed = tonumber(ctx.colorsUsed) or 2
		colorsUsed = math.floor(colorsUsed)
		if colorsUsed < 2 then colorsUsed = 2 end
		if colorsUsed > 4 then colorsUsed = 4 end

		-- Build ordered color list [1..colorsUsed]
		local colors = {}
		colors[1] = color1
		if colorsUsed >= 2 then
			colors[2] = color2 or color1
		end
		if colorsUsed >= 3 then
			colors[3] = color3 or colors[2] or color1
		end
		if colorsUsed >= 4 then
			colors[4] = color4 or colors[3] or colors[2] or color1
		end

		-- If we still don't have a second color, bail out
		if not colors[1] or not colors[2] then
			print("MajorPoint: missing second color, reverting to single-color fill")
			return
		end

		-- Polygon has no fill lines, nothing to color
		if not poly.fillLines or #poly.fillLines == 0 then
			---print("MajorPoint: no fill lines to color")
			return
		end

		-- Chunk length from ctx fallback
		local chunkLength = tonumber(ctx.chunkLength) or 0.8
		if chunkLength <= 0 then chunkLength = 0.8 end
		local CHUNK_LEN = chunkLength

		-- Blend percent → how much neighbor mixing/noise (0..1)
		local blendPct = tonumber(ctx.colorBlendPrecent) or 0
		blendPct = math.clamp(blendPct, 0, 100)
		local noiseStrength = blendPct / 100 -- 0 = clean bands, 1 = very speckled
		local flipProb = 0.5 * noiseStrength -- max 50% chance to flip to neighbor

		----------------------------------------------------------------
		-- Gradient setup (same as before, but reused for multi-colors)
		----------------------------------------------------------------
		local minX, maxX, minZ, maxZ = getBBox(poly.outer)
		local centerX = 0.5 * (minX + maxX)
		local centerZ = 0.5 * (minZ + maxZ)

		local blendFace = tostring(ctx.colorBlendFace or "X")
		local ax, az, bx, bz

		if blendFace == "X" then
			ax, az = maxX, centerZ -- near +X → favors low-t side
			bx, bz = minX, centerZ
		elseif blendFace == "x" then
			ax, az = minX, centerZ
			bx, bz = maxX, centerZ

		elseif blendFace == "Y" then
			ax, az = centerX, maxZ
			bx, bz = centerX, minZ
		elseif blendFace == "y" then
			ax, az = centerX, minZ
			bx, bz = centerX, maxZ

		elseif blendFace == "XY" then
			ax, az = maxX, maxZ
			bx, bz = minX, minZ
		elseif blendFace == "Xy" then
			ax, az = maxX, minZ
			bx, bz = minX, maxZ
		elseif blendFace == "xY" then
			ax, az = minX, maxZ
			bx, bz = maxX, minZ
		elseif blendFace == "xy" then
			ax, az = minX, minZ
			bx, bz = maxX, maxZ
		else
			-- fallback: behave like "X"
			ax, az = maxX, centerZ
			bx, bz = minX, centerZ
		end

		local gx, gz = bx - ax, bz - az
		local gLen2 = gx * gx + gz * gz
		if gLen2 < 1e-8 then
			-- degenerate gradient; don't modify anything
			return
		end

		-- Map a world point → t in [0,1] along gradient
		local function gradientT(px, pz)
			local dx, dz = px - ax, pz - az
			local t = (dx * gx + dz * gz) / gLen2
			if t < 0 then t = 0 elseif t > 1 then t = 1 end
			return t
		end

		----------------------------------------------------------------
		-- Multi-point gradient: each color has a center in [0,1]
		----------------------------------------------------------------
		local centers = {}
		if colorsUsed == 2 then
			centers[1] = 0.0
			centers[2] = 1.0
		else
			local denom = (colorsUsed - 1)
			for i = 1, colorsUsed do
				centers[i] = (i - 1) / denom
			end
		end

		-- Triangular membership: each color peaks at center[i] = 1.0,
		-- and falls linearly to 0 halfway to neighbors.
		local span = (colorsUsed > 1) and (1 / (colorsUsed - 1)) or 1

		local function computeBaseScores(t)
			local bestIdx, bestScore = nil, -1
			local secondIdx, secondScore = nil, -1

			for i = 1, colorsUsed do
				local d = math.abs(t - centers[i])
				local s = 1.0 - (d / span) -- triangle
				if s < 0 then s = 0 end

				if s > bestScore then
					secondIdx, secondScore = bestIdx, bestScore
					bestIdx, bestScore = i, s
				elseif s > secondScore then
					secondIdx, secondScore = i, s
				end
			end

			-- Ensure we always have a second candidate (even if score is 0)
			if not secondIdx then
				secondIdx, secondScore = bestIdx, bestScore
			end

			return bestIdx, bestScore, secondIdx, secondScore
		end

		----------------------------------------------------------------
		-- Build segments
		----------------------------------------------------------------
		local linesByColor = {}
		for i = 1, colorsUsed do
			local cid = colors[i]
			if cid then
				linesByColor[cid] = {}
			end
		end
		local mixedLines = {} -- flattened, in scan order

		local function addSegment(colorId, sx, sz, ex, ez)
			if math.abs(ex - sx) < 1e-6 and math.abs(ez - sz) < 1e-6 then
				return
			end
			local seg = {
				start = { x = sx, z = sz },
				["end"] = { x = ex, z = ez },
				colorId = colorId,
			}
			linesByColor[colorId] = linesByColor[colorId] or {}
			table.insert(linesByColor[colorId], seg)
			table.insert(mixedLines, seg)
		end

		for _, seg in ipairs(poly.fillLines) do
			local x1, z1 = seg.start.x, seg.start.z
			local x2, z2 = seg["end"].x, seg["end"].z
			local dx, dz = x2 - x1, z2 - z1
			local length = math.sqrt(dx * dx + dz * dz)

			if length >= 1e-6 then
				local approxChunks = length / CHUNK_LEN
				local nChunks = math.max(1, math.floor(approxChunks + 0.5))
				local step = 1 / nChunks

				for i = 0, nChunks - 1 do
					local s0 = i * step
					local s1 = (i + 1) * step
					local mid = 0.5 * (s0 + s1)

					local midX = x1 + dx * mid
					local midZ = z1 + dz * mid

					-- Position along gradient
					local t = gradientT(midX, midZ)

					-- Which color is strongest here (and second-strongest)
					local bestIdx, bestScore, secondIdx, secondScore = computeBaseScores(t)
					if bestIdx == nil then
						bestIdx, secondIdx = 1, 2
						bestScore, secondScore = 1, 0
					end

					-- Make neighbor probability depend on how strong that neighbor is.
					-- baseSecond goes from ~0 (deep inside main color) to ~0.5 at the boundary.
					local denom = (bestScore or 0) + (secondScore or 0)
					local baseSecond = 0
					if denom > 1e-6 then
						baseSecond = (secondScore or 0) / denom
					end

					-- Overall probability of picking the neighbor:
					-- - scaled by noiseStrength (from ColorBlendPrecent)
					-- - zero when neighbor is "far", max ~0.5*noiseStrength at boundaries
					local pSecond = baseSecond * noiseStrength

					local noiseVal = hashNoise01(midX, midZ, COLOR_NOISE_SEED)
					local chosenIdx = bestIdx
					if secondIdx and secondIdx ~= bestIdx and noiseVal < pSecond then
						chosenIdx = secondIdx
					end


					local chosenColor = colors[chosenIdx] or colors[1]

					local sx = (i == 0) and x1 or (x1 + dx * s0)
					local sz = (i == 0) and z1 or (z1 + dz * s0)
					local ex = x1 + dx * s1
					local ez = z1 + dz * s1

					addSegment(chosenColor, sx, sz, ex, ez)
				end
			end
		end

		-- Store back
		poly.fillLinesByColor = linesByColor
		poly.fillLines = mixedLines

	end,

	Noise = function(poly, ctx)
		-- 1) Build normal borders + fill lines first
		buildEdgeLoopsForPolygon(poly)
		buildFillLinesForPolygon(poly)

		-- Base colors
		local color1 = ctx.colorId or poly.colorId
		local color2 = ctx.colorId2 or poly.colorId2
		local color3 = ctx.colorId3 or poly.colorId3
		local color4 = ctx.colorId4 or poly.colorId4

		-- Require at least 2 colors for this mode
		local colorsUsed = tonumber(ctx.colorsUsed) or 2
		colorsUsed = math.floor(colorsUsed)
		if colorsUsed < 2 then colorsUsed = 2 end
		if colorsUsed > 4 then colorsUsed = 4 end

		-- Build ordered color list [1..colorsUsed]
		local colors = {}
		colors[1] = color1
		if colorsUsed >= 2 then
			colors[2] = color2 or color1
		end
		if colorsUsed >= 3 then
			colors[3] = color3 or colors[2] or color1
		end
		if colorsUsed >= 4 then
			colors[4] = color4 or colors[3] or colors[2] or color1
		end

		-- If we still don't have a second color, bail out to avoid nil ids
		if not colors[1] or not colors[2] then
			print("Noise: missing second color, reverting to single-color fill")
			return
		end

		if not poly.fillLines or #poly.fillLines == 0 then
			print("Noise: no fill lines to color")
			return
		end

		-- Chunk length comes from ctx (fallback to 0.3)
		local chunkLength = tonumber(ctx.chunkLength) or 0.3
		if chunkLength <= 0 then chunkLength = 0.3 end
		local CHUNK_LEN = chunkLength

		-- 2) Compute weights from ColorBlendPrecent
		local blendPct = tonumber(ctx.colorBlendPrecent) or 0
		blendPct = math.clamp(blendPct, 0, 100)

		-- weights[i] is percentage for colors[i]
		local weights = {}

		if colorsUsed == 2 then
			-- any 0–100 works here
			weights[2] = blendPct
			weights[1] = 100 - weights[2]
		elseif colorsUsed == 3 then
			-- each secondary max 33%
			local perCap = 33
			local per = math.min(blendPct, perCap)
			weights[2] = per
			weights[3] = per
			weights[1] = 100 - per * 2
		else -- colorsUsed == 4
			-- each secondary max 25%
			local perCap = 25
			local per = math.min(blendPct, perCap)
			weights[2] = per
			weights[3] = per
			weights[4] = per
			weights[1] = 100 - per * 3
		end

		-- Make sure all weights are non-negative
		local sum = 0
		for i = 1, colorsUsed do
			weights[i] = math.max(weights[i] or 0, 0)
			sum = sum + weights[i]
		end
		if sum <= 0 then
			-- fallback: all main color
			weights = {}
			weights[1] = 1
			sum = 1
		end

		-- Normalize to 0–1 for sampling
		for i = 1, colorsUsed do
			weights[i] = weights[i] / sum
		end

		-- Build cumulative thresholds: t1, t2, t3, ...
		local thresholds = {}
		local acc = 0
		for i = 1, colorsUsed do
			acc = acc + weights[i]
			thresholds[i] = acc
		end
		-- ensure last is exactly 1.0
		thresholds[colorsUsed] = 1.0

		-- 3) Storage for output segments
		local linesByColor = {}
		for i = 1, colorsUsed do
			local cid = colors[i]
			if cid then
				linesByColor[cid] = {}
			end
		end
		local mixedLines = {} -- flattened, in scan order

		local function addSegment(colorId, sx, sz, ex, ez)
			if math.abs(ex - sx) < 1e-6 and math.abs(ez - sz) < 1e-6 then
				return
			end
			local seg = {
				start = { x = sx, z = sz },
				["end"] = { x = ex, z = ez },
				colorId = colorId,
			}
			linesByColor[colorId] = linesByColor[colorId] or {}
			table.insert(linesByColor[colorId], seg)
			table.insert(mixedLines, seg)
		end

		-- Choose a color index based on noise in [0,1)
		local function pickColorIndex(u)
			for i = 1, colorsUsed do
				if u <= thresholds[i] then
					return i
				end
			end
			return colorsUsed
		end

		-- 4) Chunk the original fill lines using CHUNK_LEN, assign colors by noise
		for _, seg in ipairs(poly.fillLines) do
			local x1, z1 = seg.start.x, seg.start.z
			local x2, z2 = seg["end"].x, seg["end"].z
			local dx, dz = x2 - x1, z2 - z1
			local length = math.sqrt(dx * dx + dz * dz)

			if length >= 1e-6 then
				local approxChunks = length / CHUNK_LEN
				local nChunks = math.max(1, math.floor(approxChunks + 0.5))
				local step = 1 / nChunks

				for i = 0, nChunks - 1 do
					local s0 = i * step
					local s1 = (i + 1) * step
					local mid = 0.5 * (s0 + s1)

					local midX = x1 + dx * mid
					local midZ = z1 + dz * mid

					-- Deterministic "random" in [0,1]
					local noiseVal = hashNoise01(midX, midZ, COLOR_NOISE_SEED)

					local idx = pickColorIndex(noiseVal)
					local chosenColor = colors[idx] or colors[1]

					local sx = (i == 0) and x1 or (x1 + dx * s0)
					local sz = (i == 0) and z1 or (z1 + dz * s0)
					local ex = x1 + dx * s1
					local ez = z1 + dz * s1

					addSegment(chosenColor, sx, sz, ex, ez)
				end
			end
		end

		-- 5) Store results back on the polygon
		poly.fillLinesByColor = linesByColor
		poly.fillLines = mixedLines
	end
}

-- 2D segment length
local function segmentLength2D(x1, z1, x2, z2)
	local dx = x2 - x1
	local dz = z2 - z1
	return math.sqrt(dx*dx + dz*dz)
end

-- Compute length of all loops: { { {x,z}, ... }, { ... }, ... }
local function totalLoopLength(loops)
	local total = 0
	for _, loop in ipairs(loops or {}) do
		if #loop >= 2 then
			for i = 1, #loop do
				local a = loop[i]
				local b = loop[(i % #loop) + 1]
				total += segmentLength2D(a[1], a[2], b[1], b[2])
			end
		end
	end
	return total
end

-- Compute length + detailed list for fillLines
local function analyzeFillLines(fillLines)
	local lines = fillLines or {}
	local totalLen = 0
	local segments = {} -- per-segment info

	for idx, seg in ipairs(lines) do
		local sx = seg.start.x
		local sz = seg.start.z
		local ex = seg["end"].x
		local ez = seg["end"].z
		local len = segmentLength2D(sx, sz, ex, ez)

		totalLen += len

		segments[#segments+1] = {
			index = idx,
			length = len,
			startX = sx,
			startZ = sz,
			endX = ex,
			endZ = ez,
			colorId = seg.colorId, -- may be nil; fine
		}
	end

	return totalLen, #lines, segments
end

-- MASTER: compute debug stats for all polygons
local function computePolygonDebugStats(polygons)
	local stats = {
		polygonCount = #polygons,
		totalOuterArea = 0,
		totalOuterPerimeter = 0,
		totalEdgeLoopLength = 0,
		totalFillLineLength = 0,
		totalFillSegments = 0,
		perPolygon = {},
	}

	for idx, poly in ipairs(polygons) do
		local outer = poly.outer or {}
		local edgeLoops = poly.edgeLoops or {}
		local fillLines = poly.fillLines or {}

		-- outer area / perimeter
		local area = (#outer >= 3) and polygonArea(outer) or 0
		local outerPerimeter = 0
		if #outer >= 2 then
			for i = 1, #outer do
				local a = outer[i]
				local b = outer[(i % #outer) + 1]
				outerPerimeter += segmentLength2D(a[1], a[2], b[1], b[2])
			end
		end

		-- all edge loop length
		local allEdgeLoopLen = totalLoopLength(edgeLoops)

		-- fillLines
		local fillLen, fillCount, fillSegments = analyzeFillLines(fillLines)

		stats.totalOuterArea += area
		stats.totalOuterPerimeter += outerPerimeter
		stats.totalEdgeLoopLength += allEdgeLoopLen
		stats.totalFillLineLength += fillLen
		stats.totalFillSegments += fillCount

		stats.perPolygon[#stats.perPolygon+1] = {
			index = idx,
			instanceName = poly.instance and poly.instance.Name or ("[poly "..idx.."]"),
			colorId = poly.colorId,
			area = area,
			outerPerimeter = outerPerimeter,
			edgeLoopLength = allEdgeLoopLen,
			fillLineLength = fillLen,
			fillSegmentCount = fillCount,
			fillSegments = fillSegments,
			edgeLoopCount = #edgeLoops,
		}
	end

	return stats
end

-- Build polygons from the union of all the parts
local function generatePolygons(location)

	local initial = gatherInitialObjects(location)
	local frags = carveFragments(initial)
	local finalList = clusterAndUnion(frags)

	-- Now detect voids using the *final* combined shapes, not the raw initial shapes
	local rawVoids = detectVoidsOnFinal(finalList)

	-- bucket holes per final entry
	local holesByEntry = {}
	for _, e in ipairs(finalList) do
		holesByEntry[e] = {}
	end

	for _, loop in ipairs(rawVoids) do
		local c = computeCentroid(loop)

		-- pick the *lowest index* polygon whose OUTER contains the centroid
		local bestE, bestIdx = nil, math.huge
		for _, e in ipairs(finalList) do
			if pointInPolygon(c, e.outer) then
				-- read the Index back off the instance (clusterAndUnion dropped 'index')
				local idx = getWithDefault(e.instance, "Index", 9999)
				if idx < bestIdx then
					bestIdx = idx
					bestE = e
				end
			end
		end

		if bestE then
			table.insert(holesByEntry[bestE], loop)
		end
	end

	-- finalize: union the holes per outer
	for _, e in ipairs(finalList) do
		e.holes = unionLoops(holesByEntry[e] or {})
	end

	-- shrink OUTER by half density before borders/fill outter loop
	for _, poly in ipairs(finalList) do
		local d = poly.density or 0
		if d > 0 and poly.outer and #poly.outer >= 3 then
			-- move the outer border inward by half of the density
			local inset = offsetLoop(poly.outer, d * 0.5)
			if inset and #inset >= 3 and polygonArea(inset) > 1e-6 then
				poly.outer = inset
			else
				-- if it collapses, keep original so we don't explode
				warn(("[%s] globalInset: offsetLoop collapsed at d=%.3f, keeping original outer")
					:format(poly.instance and poly.instance.Name or "<nil>", d * 0.5))
			end
		end
	end

	-- choose fill mode per polygon
	for _, poly in ipairs(finalList) do
		local fillType = poly.colorFillType or "Fill"
		local fn = colorFillMap[fillType]

		if not fn then
			warn(("[colorFill] Unknown fill type '%s' on %s, falling back to 'Fill'")
				:format(
					tostring(fillType),
					poly.instance and poly.instance:GetFullName() or "<poly>"
				)
			)
			fn = colorFillMap.Fill
		end

		fn(poly, {
			colorId = poly.colorId,
			colorId2 = poly.colorId2,
			colorId3 = poly.colorId3,
			colorId4 = poly.colorId4,
			colorsUsed = poly.colorsUsed,
			chunkLength = poly.chunkLength,
			colorBlendFace = poly.colorBlendFace,
			colorBlendPrecent = poly.colorBlendPrecent,
			colorBlendEdgeLines = poly.colorBlendEdgeLines,
			density = poly.density,
			edgeRows = poly.edgeRows,
			motorSpeed = poly.motorSpeed,
			instance = poly.instance,
		})
	end

	-- choose fill mode per polygon
	for _, poly in ipairs(finalList) do
		local fillType = poly.colorFillType or "Fill"
		local fn = colorFillMap[fillType] or colorFillMap.Fill

		fn(poly, {
			colorId = poly.colorId,
			colorId2 = poly.colorId2,
			colorId3 = poly.colorId3,
			colorId4 = poly.colorId4,
			colorsUsed = poly.colorsUsed,
			chunkLength = poly.chunkLength,
			colorBlendFace = poly.colorBlendFace,
			colorBlendPrecent = poly.colorBlendPrecent,
			ColorBlendEdgeLines = poly.ColorBlendEdgeLines,
			density = poly.density,
			edgeRows = poly.edgeRows,
			motorSpeed = poly.motorSpeed,
			instance = poly.instance,
		})
	end

	return finalList
end

-- Generate gcode commands
local function generateGCode(polygons)
	local parts = {}
	local function emit(cmd) table.insert(parts, cmd) end

	-- Step delay updated per polygon
	local currentMs = 2.5
	
	-- Max down rotate tool degree
	local MAX_DOWN_ROTATE_DEG = 24
	
	-- Max down travel distance in studs when not on a tuft line
	local MAX_DOWN_TRAVEL_STUDS = .4
	
	-- Step delay for Y axis
	local TOOL_Y_DELAY_MS = 10

	-- Only send when change >= this many degrees
	local ANGLE_CHANGE_DEADBAND = 2
	local lastAngleSent = nil
	
	local function angleToward(ax, az, bx, bz)
		local dx, dz = bx-ax, bz-az
		if dx == 0 and dz == 0 then return nil end
		local a = math.deg(math.atan2(dz, dx))
		return (a + 360) % 360
	end

	local function signedDeltaDeg(a, b) -- a - b in [-180,180)
		return ((a - b + 540) % 360) - 180
	end

	-- Call this before starting edges/fills in a new direction
	local function emitHeadingToward(ax, az, bx, bz)
		local dx, dz = bx - ax, bz - az
		if dx == 0 and dz == 0 then return end
		local angle = math.deg(math.atan2(dz, dx))
		angle = (angle + 360.0) % 360.0
		local a = math.floor(angle + 0.5)
		if a == 360 then a = 0 end

		-- deadband to avoid chatty P’s
		if lastAngleSent == nil then
			emit("P" .. decimalToBase62(absClampTo238k(a), 2))
			lastAngleSent = a
		else
			local delta = ((a - lastAngleSent + 540) % 360) - 180
			if math.abs(delta) >= ANGLE_CHANGE_DEADBAND then
				emit("P" .. decimalToBase62(absClampTo238k(a), 2))
				lastAngleSent = a
			end
		end
	end

	local posX, posZ = 0, 0
	local toolIsDown = false
	local absXSteps, absZSteps = 0, 0
	
	local gunEnabled = false

-- Disable tuft gun motor
	local function gunDisable()
		if gunEnabled then
			emit("HD")
			gunEnabled = false
		end
	end

-- Enable tuft gun motor
	local function gunEnable()
		if not gunEnabled then
			emit("HE")
			gunEnabled = true
		end
	end
	
	-- Disable stepper motors
	local function steppersDisable()
		if gunEnabled then
			emit("KD")
			gunEnabled = false
		end
	end

-- Enable stepper motors
	local function steppersEnable()
		if not gunEnabled then
			emit("KE")
			gunEnabled = true
		end
	end

-- Move Y up
	local function toolUp()
		-- MUST disable gun BEFORE lifting Y
		gunDisable()
		emit("R" .. twoDigit(TOOL_Y_DELAY_MS))
		toolIsDown = false
	end

-- Move Y down
	local function toolDown()
		emit("S" .. twoDigit(TOOL_Y_DELAY_MS))
		toolIsDown = true

		-- Gun should be ON whenever tool is down (during stitching moves)
		gunEnable()
	end

	-- Emits a packed 'O' (ABSOLUTE steps)
	local function emitParallelMoveAbsSteps(xAbsSteps, zAbsSteps, baseDelayMs)
		-- no-op if we're already there
		if xAbsSteps == absXSteps and zAbsSteps == absZSteps then return end
		baseDelayMs = clamp(math.floor((baseDelayMs or 0.2) * 10 + 0.5) / 10, 0.2, 9.9)

		local cmd = makeOAbs(baseDelayMs, xAbsSteps, zAbsSteps)
		if cmd then emit(cmd) end

		-- track authoritative absolute positions
		absXSteps, absZSteps = xAbsSteps, zAbsSteps
	end

	-- Move to absolute world position (studs) by converting to absolute steps
	local function emitMoveToWorldStuds(targetXStuds, targetZStuds, delayTenths)
		-- clamp in world space
		targetXStuds, targetZStuds = clampWorldStuds(targetXStuds, targetZStuds)

		-- convert targets to ABS steps
		local targetXSteps = studsToSteps(targetXStuds)
		local targetZSteps = studsToSteps(targetZStuds)

		local baseDelayMs = clamp((delayTenths or MIN_DELAY_TENTHS) / 10, 0.2, 9.9)
		lastBaseDelayMs = baseDelayMs

		-- 🔵 ABSOLUTE O move
		local cmd = makeOAbs(baseDelayMs, targetXSteps, targetZSteps)
		if cmd then emit(cmd) end

		-- Keep authoritative tracking aligned with targets
		absXSteps, absZSteps = targetXSteps, targetZSteps
	end

	-- Studs-version (ABSOLUTE): converts target world studs -> absolute steps, emits O(abs)
	local function emitParallelMoveStuds(targetXStuds, targetZStuds, baseDelayTenths)
		-- clamp targets in world space
		targetXStuds, targetZStuds = clampWorldStuds(targetXStuds, targetZStuds)

		-- convert to ABSOLUTE steps
		local xAbsSteps = studsToSteps(targetXStuds)
		local zAbsSteps = studsToSteps(targetZStuds)

		-- delay handling
		local baseDelayMs = clamp((baseDelayTenths or MIN_DELAY_TENTHS) / 10, 0.2, 9.9)
		lastBaseDelayMs = baseDelayMs

		-- 🔵 absolute O (uses makeOAbs under the hood)
		emitParallelMoveAbsSteps(xAbsSteps, zAbsSteps, baseDelayMs)

		-- track authoritative absolute positions
		absXSteps, absZSteps = xAbsSteps, zAbsSteps
	end

	-- hopToStart:
	--   Move to (xStuds,zStuds) to begin a path.
	--   nextX/nextZ is the point you will move toward AFTER lowering (direction of stitching).
	local function hopToStart(xStuds, zStuds, nextX, nextZ, alwaysLift, densityStuds)
		local dx, dz = xStuds - posX, zStuds - posZ
		local dist = math.sqrt(dx*dx + dz*dz)
		local travelAng = angleToward(posX, posZ, xStuds, zStuds)
		local rotTooBig = false
		if toolIsDown and travelAng and lastAngleSent ~= nil then
			rotTooBig = math.abs(signedDeltaDeg(travelAng, lastAngleSent)) > MAX_DOWN_ROTATE_DEG
		end

		local willLift = alwaysLift or dist > MAX_DOWN_TRAVEL_STUDS or rotTooBig

		if willLift then
			if toolIsDown then toolUp() else gunDisable() end

			-- ONLY rotate for the upcoming down-direction (start -> next)
			if nextX ~= nil and nextZ ~= nil then
				emitHeadingToward(xStuds, zStuds, nextX, nextZ)
			end

			-- Travel move while UP (no extra P)
			local dx, dz = xStuds - posX, zStuds - posZ
			if dx ~= 0 or dz ~= 0 then
				local moveDelayTenths = upOrDownDelayTenths(false, currentMs) -- tool up speed
				emitMoveToWorldStuds(xStuds, zStuds, moveDelayTenths)
				posX, posZ = xStuds, zStuds
			end

			toolDown() -- S then DE
		else
			-- unchanged: down-travel branch keeps gun enabled and rotates before moving
		end
	end

	-- Enable Motors
	steppersEnable()
	
	-- Home Motors
	emit("Q")
	
	-- Lift Y axis before starting
	toolUp()

	----------------------------------------------------------------
	-- Collect all colors that actually appear (base + per-segment)
	----------------------------------------------------------------
	local colorSet = {}

	for _, poly in ipairs(polygons) do
		-- base color (for edges + simple Fill)
		if poly.colorId ~= nil then
			colorSet[poly.colorId] = true
		end

		-- per-color fill segments from MajorPoint / Noise
		if poly.fillLinesByColor then
			for cid, segs in pairs(poly.fillLinesByColor) do
				if cid ~= nil and #segs > 0 then
					colorSet[cid] = true
				end
			end
		end
	end

	local colorIds = {}
	for cid in pairs(colorSet) do
		table.insert(colorIds, cid)
	end
	table.sort(colorIds)

	-- For each color: edges (if base color) + fills for that color
	for ci, cid in ipairs(colorIds) do

		for _, poly in ipairs(polygons) do
			local dStuds = poly.density or 1
			currentMs = clamp(tonumber(poly.motorSpeed) or 2.5, 0.2, 9.9)

			--------------------------------------------------------
			-- 1) EDGE LOOPS: only when polygon's main color == cid
			--------------------------------------------------------
			if poly.colorId == cid then
				for _, loop in ipairs(poly.edgeLoops or {}) do

					local a = loop[1]
					local b = loop[2] or loop[1] -- safe fallback
					hopToStart(a[1], a[2], b[1], b[2], true, dStuds)

					for i = 1, #loop do
						local b = loop[(i % #loop) + 1]
						emitHeadingToward(posX, posZ, b[1], b[2])
						emitMoveToWorldStuds(
							b[1], b[2],
							upOrDownDelayTenths(toolIsDown, currentMs)
						)
						posX, posZ = b[1], b[2]
					end

					if toolIsDown then toolUp() end
				end
			end

			--------------------------------------------------------
			-- 2) FILL LINES for this color
			-- Prefer per-color list; fall back to base behavior.
			--------------------------------------------------------
			local segList = nil

			if poly.fillLinesByColor and poly.fillLinesByColor[cid] then
				-- segments explicitly tagged with this color
				segList = poly.fillLinesByColor[cid]
			elseif cid == poly.colorId then
				-- simple Fill polygons (no per-color splitting)
				segList = poly.fillLines
			end

			if segList and #segList > 0 then
				local lastX, lastZ = nil, nil

				for _, seg in ipairs(segList) do
					local a, b = seg.start, seg["end"]
					local hopFromNewPoly = (lastX == nil)

					-- hop to the segment start:
					-- - if we lift: DD -> R -> rotate to (a->b) -> travel -> S -> DE
					-- - if we don't lift: keep DE, rotate before moving, move down
					hopToStart(a.x, a.z, b.x, b.z, hopFromNewPoly, dStuds)

					-- now stitch the segment (tool is down and gun is enabled here)
					emitHeadingToward(posX, posZ, b.x, b.z)
					emitMoveToWorldStuds(
						b.x, b.z,
						upOrDownDelayTenths(toolIsDown, currentMs)
					)

					posX, posZ = b.x, b.z
					lastX, lastZ = posX, posZ
				end

				if toolIsDown then toolUp() end
			end
		end

		-- Color change between passes
		if ci < #colorIds then
			emit("C")
		end
	end

	if toolIsDown then
		toolUp() 
	end
	
	-- Disable gun
	gunDisable()

	-- Home motors
	emit("Q")
	
	-- Disable steppers
	steppersDisable()

	return table.concat(parts, ";") .. ";"
end

-- Chunk Gcode into payloads for transport for arduino
local function processGCodeForTransport(gCode)

	local chunkSize = 55
	local result = {}
	local dataChunks = {}

	-- Split by semicolons, remove empty strings
	for entry in string.gmatch(gCode, "[^;]+") do
		if #entry > 0 then
			table.insert(dataChunks, entry)
		end
	end

	local currentChunk = ""
	local chunkIndex = 0

	for i, data in ipairs(dataChunks) do
		-- Try to add ; + data (except if it's the first)
		local separator = (currentChunk == "") and "" or ";"
		local newData = separator .. data
		if #currentChunk + #newData <= chunkSize then
			currentChunk = currentChunk .. newData
		else
			-- Finalize current chunk
			chunkIndex += 1
			table.insert(result, decimalToBase62(chunkIndex, 5) .. currentChunk)
			-- Start new chunk with current data
			currentChunk = data
		end
	end

	-- Final leftover
	if #currentChunk > 0 then
		chunkIndex += 1
		table.insert(result, decimalToBase62(chunkIndex, 5) .. currentChunk)
	end

	return result
end

-- Get encoded client ID and secret
local function getOAuthToken()

	local url = "https://api2.arduino.cc/iot/v1/clients/token"

	local body = "grant_type=client_credentials" ..
		"&client_id=" .. CLIENT_ID ..
		"&client_secret=" .. CLIENT_SECRET ..
		"&audience=https://api2.arduino.cc/iot"

	local headers = { ["Content-Type"] = "application/x-www-form-urlencoded" }

	-- Attempt to make the request
	local success, response = pcall(function()
		return HttpService:RequestAsync({
			Url = url,
			Method = "POST",
			Headers = headers,
			Body = body
		})
	end)

	-- Result 
	if success and response.StatusCode == 200 then
		local data = HttpService:JSONDecode(response.Body)
		return data["access_token"]
	else
		warn("Failed to get OAuth token: " .. response.Body)
		return nil
	end
end

-- Function to read a value from an Arduino IoT Cloud property
local function readFromArduinoCloud(varId)

	-- Get the OAuth token
	local token = getOAuthToken()
	if not token then
		warn("No valid OAuth token!")
		return
	end

	local API_URL = "https://api2.arduino.cc/iot/v2/things/" .. THING_ID .. "/properties/" .. varId

	local headers = {
		["Authorization"] = "Bearer " .. token
	}

	-- Attempt to make the request
	local success, response = pcall(function()
		return HttpService:RequestAsync({
			Url = API_URL,
			Method = "GET",
			Headers = headers
		})
	end)

	-- Result
	if success and response.StatusCode == 200 then
		local data = HttpService:JSONDecode(response.Body)
		return data["last_value"]
	else
		warn("Failed to retrieve property value: " .. response.Body)
		return nil
	end
end

-- Send data to the Arduino IoT Cloud
local function sendToArduino(varName, varId, varType, varPremission, updateStrategy, varValue)
	local token = getOAuthToken()
	if not token then
		warn("❌ No valid OAuth token!")
		return
	end
	

	-- Https request string
	local apiUrl = "https://api2.arduino.cc/iot/v2/things/" .. THING_ID .. "/properties/" .. varId.. "/publish"

	local headers = {
		["Authorization"] = "Bearer " .. token,
		["Content-Type"] = "application/json"
	}

	-- payload with required attributes
	local body = HttpService:JSONEncode({
		value = varValue,
		name = varName,
		type = varType,
		permission = varPremission,
		update_strategy = updateStrategy
	})

	lastDataOut = tick() * 1000

	-- Attempt to send the HTTP request
	local success, response = pcall(function()
		return HttpService:RequestAsync({
			Url = apiUrl,
			Method = "PUT",
			Headers = headers,
			Body = body
		})
	end)

	-- Response handler
	if success then

		if response.StatusCode == 200 then

			-- Data sent successfully
			if (varName == "messageToArduino") then

				game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToArduino.Text = tostring(varValue)
			end

		elseif response.StatusCode == 400 then
			warn("🚨 Bad Request: Ensure all required attributes are included!")
		elseif response.StatusCode == 401 then
			warn("🚨 Unauthorized: Check if your OAuth token is valid!")
		elseif response.StatusCode == 404 then
			warn("🚨 Not Found: Check if your THING_ID or PROPERTY_ID is correct!")
		elseif response.StatusCode == 405 then
			warn("🚨 Method Not Allowed: Ensure you are using the correct HTTP method.")
		else
			warn("❌ Failed to send data: " .. response.Body)
		end
	else
		warn("❌ HTTP Request failed.")
	end
end

-- Read data saved on cloud from arduino
local function readCloudMessage(processedGCode)
	if messageToServer == nil then
		warn "Https returned nil, no processing compleated"
		return
	end
	local uniqueMessageID = string.sub(messageToServer, 1, 5)

	-- Check its at least 5 characters long
	if #uniqueMessageID == 5 then
		local IDNumber = base62ToDecimal(uniqueMessageID)

		-- Ensure it is a new message
		if IDNumber ~= lastMessageFromArduinoNumber then

			lastMessageFromArduinoNumber = IDNumber
			local messageToServer = string.sub(messageToServer, 6)

			game.Workspace.infoScreen.SurfaceGui.Frame.Frame.infoID.Text = ("IN #"..IDNumber)
			game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text = messageToServer

			-- Last command executed 7 digits 5-2
			mostRecentConfirmedExecutedCommand = string.sub(messageToServer, -7)
			lastArduinoCommunication = os.time()
			lastDataIn = tick() * 1000

			-- Arduino sending bulk data
			if string.sub(messageToServer, 1, 1) == "B" then
				messageToServer = string.sub(messageToServer, 2)

				local tokens = {}
				for token in string.gmatch(messageToServer, "([^;]+)") do
					table.insert(tokens, token)
				end

				-- Helpers
				local function b62(s) return base62ToDecimal(s or "0") end
				local function asBool(s) return (s or "0") ~= "0" end

				local function b62digitToNum(c)
					if not c or #c == 0 then return 0 end
					c = string.sub(c, 1, 1)
					local byte = string.byte(c)
					if byte >= 48 and byte <= 57 then return byte - 48 end
					if byte >= 65 and byte <= 90 then return 10 + (byte - 65) end
					if byte >= 97 and byte <= 122 then return 36 + (byte - 97) end
					return 0
				end

				local function unpack5Bools(ch)
					local n = b62digitToNum(ch)
					local b0 = bit32.band(n, bit32.lshift(1, 0)) ~= 0
					local b1 = bit32.band(n, bit32.lshift(1, 1)) ~= 0
					local b2 = bit32.band(n, bit32.lshift(1, 2)) ~= 0
					local b3 = bit32.band(n, bit32.lshift(1, 3)) ~= 0
					local b4 = bit32.band(n, bit32.lshift(1, 4)) ~= 0
					return b0, b1, b2, b3, b4
				end

				-- Flags
				local flagsChar = tokens[1] and string.sub(tokens[1], 1, 1) or "0"
				local ArduinoErrorPaused,
				ArduinoWaitPaused,
				ArduinoScriptGCode,
				ArduinoMotorEnabled,
				ArduinoFanEnabled =
					unpack5Bools(flagsChar)

				local inputsChar = tokens[2] and tokens[2]:sub(1,1) or "0"
				local ArduinoXLeverTriggered,
				ArduinoYLeverTriggered,
				ArduinoZLeverTriggered,
				ArduinoRMagneticEncoderBool,
				ArduinoLastSwitchRead =
					unpack5Bools(inputsChar)

				local ArduinoXStepPosition = b62(tokens[3])
				local ArduinoXStepTotal = b62(tokens[4])

				local ArduinoYStepPosition = b62(tokens[5])
				local ArduinoYStepTotal = b62(tokens[6])

				local ArduinoZStepPosition = b62(tokens[7])
				local ArduinoZStepTotal = b62(tokens[8])

				local ArduinoRStepRotation = tonumber(tokens[9]) or 0
				local ArduinoRStepTotal = b62(tokens[10])

				local ArduinoMotorUpTime = b62(tokens[11])
				local ArduinoMotorDownTime = b62(tokens[12])

				-- If you want seconds:
				local ArduinoMotorUpSec = ArduinoMotorUpTime / 10
				local ArduinoMotorDownSec = ArduinoMotorDownTime / 10

				-- UI updates
				local frame = game.Workspace.infoScreen.SurfaceGui.Frame.Frame

				-- Extract payload/command ids from the 7-char tail
				local cmdStr = tostring(mostRecentConfirmedExecutedCommand or "")
				local payloadIdB62 = string.sub(cmdStr, 1, 5)
				local cmdIdB62 = string.sub(cmdStr, -2)
				local payloadIdDec = base62ToDecimal(payloadIdB62 or "0")
				local cmdIdDec = base62ToDecimal(cmdIdB62 or "0")

				frame.lastExecutedPayloadID.Text = "PLOAD #" .. tostring(payloadIdDec)
				frame.lastExecutedCommand.Text = "CMD #" .. tostring(cmdIdDec)

				-- Update client
				eventToClient:FireAllClients("B",
					ArduinoErrorPaused and "Error Stop" or "Running Smooth", ArduinoWaitPaused and "Waiting Paused" or "Running Active", ArduinoScriptGCode and "Gcode Compleated" or "Running Gcode",
					ArduinoMotorEnabled and "Steppers Engaged" or "Steppers Off", ArduinoFanEnabled and "Fans Running" or "Fans Off",
					ArduinoXLeverTriggered and "Activated" or "Off", ArduinoXStepPosition, ArduinoXStepTotal ,
					ArduinoYLeverTriggered and "Activated" or "Off", ArduinoYStepPosition, ArduinoYStepTotal ,
					ArduinoZLeverTriggered and "Activated" or "Off", ArduinoZStepPosition, ArduinoZStepTotal ,
					ArduinoRMagneticEncoderBool and "Activated" or "Off" , ArduinoRStepRotation , ArduinoRStepTotal ,
					string.format("Motors Up: %.1fs", ArduinoMotorUpSec) ,string.format("Motors Down: %.1fs", ArduinoMotorDownSec) ,
					"PLOAD #" .. tostring(payloadIdDec), "CMD #" .. tostring(cmdIdDec), messageToServer, game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToArduino.Text ,
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList1.Text ,
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList2.Text ,
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList3.Text ,
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList4.Text)
				return

			else

				-- Arduino requesting data
				if string.sub(messageToServer, 1, 1) == "R" then
					local base62Id = string.sub(messageToServer, 2, 6)

					-- Try to build a bundle starting at the requested chunk id.
					local msg, kind = buildChunkBundle(
						processedGCode,
						base62Id,
						TARGET_BUNDLE_COUNT,
						MAX_IOT_BYTES
					)

					if not msg then
						-- Fallback: search and send single chunk exactly like before
						local single = nil
						for _, chunk in ipairs(processedGCode) do
							if string.sub(chunk, 1, 5) == base62Id then
								single = "S" .. chunk
								break
							end
						end
						if single then
							task.wait(0.3)
							sendToArduino("messageToArduino", messageToArduinoID, "String", "READ_WRITE", "ON_CHANGE", single)
						else
							warn("Arduino requested invalid chunk id "..base62Id)
						end
						return
					end

					-- Send the bundle (or single-fallback if that’s what fit)
					task.wait(0.3)
					sendToArduino("messageToArduino", messageToArduinoID, "String", "READ_WRITE", "ON_CHANGE", msg)
					return
				end

				game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList4.Text = game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList3.Text
				game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList3.Text = game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList2.Text
				game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList2.Text = game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList1.Text

				if string.sub(messageToServer, 1, 1) == "E" then
					messageToServer = string.sub(messageToServer, 2)
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text = "Error "..messageToServer
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList1.Text = ("IN "..tostring(math.round(tick() * 1000-codeStartTime)/1000).." ==> "..game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text)
					return
				end
				
				if string.sub(messageToServer, 1, 1) == "e" then
					messageToServer = string.sub(messageToServer, 2)
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text = "Error "..messageToServer
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList1.Text = ("IN "..tostring(math.round(tick() * 1000-codeStartTime)/1000).." ==> "..game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text)
					return
				end

				if string.sub(messageToServer, 1, 1) == "S" then
					messageToServer = string.sub(messageToServer, 2)
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text = "Success "..messageToServer
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList1.Text = ("IN "..tostring(math.round(tick() * 1000-codeStartTime)/1000).." ==> "..game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text)
					return
				end

				if string.sub(messageToServer, 1, 1) == "P" then
					messageToServer = string.sub(messageToServer, 2)
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text = "Ping return "..messageToServer
					game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList1.Text = ("IN "..tostring(math.round(tick() * 1000-codeStartTime)/1000).." ==> "..game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text)
					waitingForResponce = false
					return
				end

				game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text = messageToServer
				game.Workspace.infoScreen.SurfaceGui.Frame.Frame.importantMessageList1.Text = ("IN "..tostring(math.round(tick() * 1000-codeStartTime)/1000).." ==> "..game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text)

				warn("Arduino send data (".. string.sub(messageToServer, 1, 1)..") ("..string.sub(messageToServer, 2)..") no processing occured")
			end	
		end
	else 
		warn("message less than ID length of 5 "..messageToServer)
	end
end

-- Start new rug
local function startNewRug(location)

	-- Generate polygons
	local polys = generatePolygons(location)

	-- Add line segments for borders and holes
	visualizePolygons(polys, 1)

	-- Add lines for edge rows
	visualizeEdgeLoops(polys, 1)

	-- Fill in polygons
	visualizeFillLines(polys, 1)

	-- Generate gcode
	local code = generateGCode(polys)

	-- Set up gcode for transport
	processedGCode = processGCodeForTransport(code)

	print(processedGCode)

	-- Debug stats
	local debugStats = computePolygonDebugStats(polys)

	game.Workspace.infoScreen.SurfaceGui.Frame.Frame.totalPolygonCount.Text = ("Polygons: "..debugStats.polygonCount)

	game.Workspace.infoScreen.SurfaceGui.Frame.Frame.totalPathDistance.Text = ("Total Line Path Inches "..math.round(debugStats.totalEdgeLoopLength + debugStats.totalFillLineLength))
	game.Workspace.infoScreen.SurfaceGui.Frame.Frame.totalPathLines.Text = ("Segments: "..debugStats.totalFillSegments)
	--setNumberValue("TotalOuterArea", debugStats.totalOuterArea)
	--setNumberValue("TotalOuterPerimeter", debugStats.totalOuterPerimeter)

	--game.Workspace.infoScreen.SurfaceGui.Frame.totalPathLines.Text = ("Paths: ".. tostring(summarizeLines(polys).count))
	--game.Workspace.infoScreen.SurfaceGui.Frame.totalPathDistance.Text = ("Total path distance: "..tostring(summarizeLines(polys).length))
	game.Workspace.infoScreen.SurfaceGui.Frame.Frame.totalPolygonSurface.Text = ("Area covered "..math.round(totalCoveredArea(polys)).. "² Inches")

end

-- Event trigger from cliet
eventToServer.OnServerEvent:Connect(function(player, order, in1, in2, in3, in4, in5)

	-- Send command to arduino cloud
	if order == "command" then
		
		-- Send if havent sent info recently
		if tick() * 1000 - lastDataOut > 1000 then
			

			sendToArduino("messageToArduino", messageToArduinoID, "String", "READ_WRITE", "ON_CHANGE", (in1))
		end
	end

	-- Rug generation
	if order == "rug" then

		-- Generate rug from roblox blocks
		if (in1) == "GenerateFromRoblox" then
			startNewRug("RugGenerationShapes")
		end

		-- Generate from 2d array file
		if (in1) == "GenerateFromImage" then
			startNewRug(ImageGenerator().Name)
		end
		
		-- Generate from 2d array file
		if (in1) == "StartProgram" then
			
			-- Inform Arduino of new script for executing
			if #processedGCode > 0 then
				local lastChunk = processedGCode[#processedGCode]
				local id62 = string.sub(lastChunk, 1, 5)
				startTPingCycle(id62)
			end
		end
		
		-- Stop Tuft Rug
		if (in1) == "StopProgram" then
			startNewRug(ImageGenerator().Name)
		end
	end

	-- End program
	if order == "StopProgram" then

	end

	-- Start program
	if order == "StartProgram" then

	end

end)

-- Constant read server loop
while true do

	-- Read cloud
	if (tick() - lastArduinoCloudRead) > 0.45 then
		lastArduinoCloudRead = tick()
		messageToServer = readFromArduinoCloud(messageToServerID)
		readCloudMessage(processedGCode)
	end

	-- Update connectivity info
	if tick() * 1000 - lastDataIn > 12000 then
		game.Workspace.infoScreen.SurfaceGui.Frame.Frame.scriptRunning.Text = "Communication Lost"
	else
		game.Workspace.infoScreen.SurfaceGui.Frame.Frame.scriptRunning.Text = "Connected"
	end

	-- Ping if havent sent info recently
	if tick() * 1000 - lastDataOut > 60000 then
		task.wait(0.5)
		sendToArduino("messageToArduino", messageToArduinoID, "String", "READ_WRITE", "ON_CHANGE", "IN")
	end

	game.Workspace.infoScreen.SurfaceGui.Frame.Frame.secondsFromInbound.Text = ("In "..math.round(tick() * 1000 - lastDataIn)/1000)
	game.Workspace.infoScreen.SurfaceGui.Frame.Frame.secondsFromOutbound.Text = ("Out "..math.round(tick() * 1000 - lastDataOut)/1000)
	game.Workspace.infoScreen.SurfaceGui.Frame.Frame.scriptRunningTime.Text = ("Up ("..math.round(math.round(tick() * 1000 - codeStartTime)/1000))..")"

	eventToClient:FireAllClients("F", ("In "..math.round(tick() * 1000 - lastDataIn)/1000), ("Out "..math.round(tick() * 1000 - lastDataOut)/1000), ("Up ("..math.round(math.round(tick() * 1000 - codeStartTime)/1000))..")", game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToServer.Text, game.Workspace.infoScreen.SurfaceGui.Frame.Frame.messageToArduino.Text)
	
	-- Re-send I T<id62> until Arduino pings back
	if waitingForResponce then
		local t = nowMs()
		if t - lastTInstantAtMs >= 80000 then
			-- I + T<id62> so Arduino treats it as an immediate 'T' command
			sendToArduino(
				"messageToArduino",
				messageToArduinoID,
				"String",
				"READ_WRITE",
				"ON_CHANGE",
				"IT" .. lastPayloadId62
			)
			lastTInstantAtMs = t
		end
	end

	task.wait(0.1)
end
